package com.example.lilotest.ui.chat

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import com.example.lilotest.data.remote.MessageRepository
import kotlinx.coroutines.launch
import java.util.Date
import java.util.regex.Pattern
import android.util.Log

class ChatViewModel : ViewModel() {

    private val TAG = "ChatViewModel"
    private val repository = MessageRepository()

    private val _messages = MutableLiveData<List<Message>>(emptyList())
    val messages: LiveData<List<Message>> = _messages

    fun sendMessage(content: String) {
        val currentMessages = _messages.value?.toMutableList() ?: mutableListOf()

        // Add user message to the list
        val userMessage = Message(
            id = System.currentTimeMillis().toString(),
            content = content,
            type = MessageType.USER,
            timestamp = Date()
        )
        currentMessages.add(userMessage)
        _messages.value = currentMessages

        // Send message to the server
        viewModelScope.launch {
            try {
                Log.d(TAG, "Sending message: $content")
                val response = repository.sendMessage(content)
                Log.d(TAG, "Received response: $response")

                // Process text with special prefixes
                processAndAddResponse(response)
            } catch (e: Exception) {
                Log.e(TAG, "Error sending message", e)

                // Handle error 
                val errorMessage = Message(
                    id = System.currentTimeMillis().toString(),
                    content = "Error: ${e.message}",
                    type = MessageType.ERROR,
                    timestamp = Date()
                )
                val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                updatedMessages.add(errorMessage)
                _messages.value = updatedMessages
            }
        }
    }

    private fun processAndAddResponse(responseText: String) {
        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()

        // Check for image url prefix
        if (responseText.contains("!IMAGEURL!")) {
            Log.d(TAG, "Found image URL prefix")
            val parts = responseText.split("!IMAGEURL!")
            val contentText = parts[0].trim()
            val imageUrl = parts[1].trim()

            Log.d(TAG, "Image URL: $imageUrl")

            // Add response to the messages list
            val responseMessage = Message(
                id = System.currentTimeMillis().toString(),
                content = contentText,
                type = MessageType.BOT,
                timestamp = Date(),
                containsImage = true,
                imageUrl = imageUrl
            )

            updatedMessages.add(responseMessage)
        }
        // Check for image data prefix
        else if (responseText.contains("!IMAGEDATA!")) {
            Log.d(TAG, "Found image data prefix")
            val parts = responseText.split("!IMAGEDATA!")
            val contentText = parts[0].trim()
            val imageData = parts[1].trim()

            Log.d(TAG, "Image data length: ${imageData.length}")

            val responseMessage = Message(
                id = System.currentTimeMillis().toString(),
                content = contentText,
                type = MessageType.BOT,
                timestamp = Date(),
                containsImage = true,
                imageData = imageData
            )
            updatedMessages.add(responseMessage)
        }
        //Regular text response
        else {
            val responseMessage = Message(
                id = System.currentTimeMillis().toString(),
                content = responseText,
                type = MessageType.BOT,
                timestamp = Date()
            )
            updatedMessages.add(responseMessage)
        }
        _messages.value = updatedMessages
    }

    fun editMessage(messageId: String, newContent: String) {
        val currentMessages = _messages.value?.toMutableList() ?: return

        // Find the index of the user message that needs to be edited
        var userMessageIndex = -1
        for (i in currentMessages.indices) {
            if (currentMessages[i].id == messageId) {
                userMessageIndex = i
                break
            }
        }

        if (userMessageIndex == -1) {
            Log.e(TAG, "Could not find message with ID: $messageId")
            return
        }

        // Update the user message
        val updatedUserMessage = currentMessages[userMessageIndex].copy(
            content = newContent,
            timestamp = Date() // Update timestamp to show it was edited
        )
        currentMessages[userMessageIndex] = updatedUserMessage

        // Check if there's a bot response after this message
        var botResponseIndex = -1
        if (userMessageIndex + 1 < currentMessages.size &&
            currentMessages[userMessageIndex + 1].type == MessageType.BOT
        ) {
            botResponseIndex = userMessageIndex + 1
        }

        // If bot response exists, mark it for replacement
        val botResponseToReplace =
            if (botResponseIndex != -1) currentMessages[botResponseIndex] else null

        // If the bot response exists, we need to replace it
        // Otherwise, we might be appending a new response later

        // Create a separate list for updating the UI immediately with just the edited user message
        val immediateUpdate = ArrayList(currentMessages)

        // Update the UI with edited user message
        _messages.value = immediateUpdate

        // Fetch a new response for the edited message
        viewModelScope.launch {
            try {
                Log.d(TAG, "Sending edited message: $newContent")
                val response = repository.sendMessage(newContent)
                Log.d(TAG, "Received response for edited message: $response")

                // Get the current messages again after the async call
                // This ensures we're working with the most up-to-date list
                val updatedMessages = _messages.value?.toMutableList() ?: return@launch

                // Find user message again, as the indices might have changed
                userMessageIndex = updatedMessages.indexOfFirst { it.id == messageId }
                if (userMessageIndex == -1) {
                    Log.e(TAG, "User message no longer exists in the list")
                    return@launch
                }

                // Create the new response message
                val responseMessage: Message = when {
                    response.contains("!IMAGEURL!") -> {
                        val parts = response.split("!IMAGEURL!")
                        val contentText = parts[0].trim()
                        val imageUrl = parts[1].trim()

                        Message(
                            id = if (botResponseToReplace != null) botResponseToReplace.id else System.currentTimeMillis()
                                .toString(),
                            content = contentText,
                            type = MessageType.BOT,
                            timestamp = Date(),
                            containsImage = true,
                            imageUrl = imageUrl
                        )
                    }

                    response.contains("!IMAGEDATA!") -> {
                        val parts = response.split("!IMAGEDATA!")
                        val contentText = parts[0].trim()
                        val imageData = parts[1].trim()

                        Message(
                            id = if (botResponseToReplace != null) botResponseToReplace.id else System.currentTimeMillis()
                                .toString(),
                            content = contentText,
                            type = MessageType.BOT,
                            timestamp = Date(),
                            containsImage = true,
                            imageData = imageData
                        )
                    }

                    else -> {
                        Message(
                            id = if (botResponseToReplace != null) botResponseToReplace.id else System.currentTimeMillis()
                                .toString(),
                            content = response,
                            type = MessageType.BOT,
                            timestamp = Date()
                        )
                    }
                }

                // Find the current position of the bot response (if it exists)
                var currentBotResponseIndex = -1
                if (botResponseToReplace != null) {
                    currentBotResponseIndex =
                        updatedMessages.indexOfFirst { it.id == botResponseToReplace.id }
                }

                // Update the list based on whether we're replacing an existing response or adding a new one
                if (currentBotResponseIndex != -1) {
                    // Replace existing bot response
                    updatedMessages[currentBotResponseIndex] = responseMessage
                } else if (userMessageIndex + 1 < updatedMessages.size) {
                    // Insert after user message but before the next message (if any)
                    updatedMessages.add(userMessageIndex + 1, responseMessage)
                } else {
                    // Add to the end of the list
                    updatedMessages.add(responseMessage)
                }

                // Update the UI with the final list
                _messages.value = updatedMessages

            } catch (e: Exception) {
                Log.e(TAG, "Error sending edited message", e)

                // Handle error
                val errorMessage = Message(
                    id = System.currentTimeMillis().toString(),
                    content = "Error: ${e.message}",
                    type = MessageType.ERROR,
                    timestamp = Date()
                )

                // Get the current messages again
                val updatedMessages = _messages.value?.toMutableList() ?: return@launch

                // Find user message again
                userMessageIndex = updatedMessages.indexOfFirst { it.id == messageId }
                if (userMessageIndex == -1) return@launch

                // Find the current position of the bot response (if it exists)
                var currentBotResponseIndex = -1
                if (botResponseToReplace != null) {
                    currentBotResponseIndex =
                        updatedMessages.indexOfFirst { it.id == botResponseToReplace.id }
                }

                // Update the list based on whether we're replacing an existing response or adding a new one
                if (currentBotResponseIndex != -1) {
                    // Replace existing bot response with error
                    updatedMessages[currentBotResponseIndex] = errorMessage
                } else {
                    // Add error after user message
                    updatedMessages.add(userMessageIndex + 1, errorMessage)
                }

                // Update the UI
                _messages.value = updatedMessages
            }
        }
    }
}