package com.example.lilotest.ui.chat

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Color
import android.graphics.drawable.GradientDrawable
import android.graphics.Typeface
import android.os.Handler
import android.os.Looper
import android.text.SpannableString
import android.text.Spanned
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.text.style.RelativeSizeSpan
import android.util.Base64
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.HorizontalScrollView
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.webkit.WebView
import android.webkit.WebSettings
import android.widget.Toast
import androidx.cardview.widget.CardView
import androidx.core.graphics.ColorUtils
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import com.example.lilotest.ui.theme.ThemeManager
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import java.util.regex.Pattern


class MessageAdapter : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {
    private val TAG = "MessageAdapter"
    private val THEME_TAG = "ThemeDebug"
    private var themeManager: ThemeManager? = null

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {
        val layoutId = when (viewType) {
            VIEW_TYPE_USER -> R.layout.item_message_user
            VIEW_TYPE_BOT_WITH_IMAGE -> R.layout.item_message_bot_with_image
            VIEW_TYPE_BOT -> R.layout.item_message_bot
            else -> R.layout.item_message_error
        }

        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false)
        
        // Initialize theme manager if not already done
        if (themeManager == null) {
            themeManager = ThemeManager(parent.context)
        }
        
        // Apply theme to the view using ThemeManager centralized styling
        when (viewType) {
            VIEW_TYPE_USER -> themeManager?.styleUserMessage(view)
            VIEW_TYPE_BOT, VIEW_TYPE_BOT_WITH_IMAGE -> themeManager?.styleBotMessage(view)
            VIEW_TYPE_ERROR -> themeManager?.styleErrorMessage(view)
        }
        
        return MessageViewHolder(view)
    }


    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)

        try {
            // Apply theme to view before binding content
            when (getItemViewType(position)) {
                VIEW_TYPE_USER -> styleUserMessage(holder.itemView, holder.itemView.context)
                VIEW_TYPE_BOT, VIEW_TYPE_BOT_WITH_IMAGE -> styleBotMessage(holder.itemView, holder.itemView.context)
                else -> styleErrorMessage(holder.itemView, holder.itemView.context)
            }

            // Get the message content safely
            val content = message.content ?: ""

            Log.d(TAG, "Processing message ID ${message.id}, content length: ${content.length}")

            // Check for code blocks or tables
            val hasSpecialBlocks = content.contains("```") || containsMarkdownTable(content)

            if (hasSpecialBlocks) {
                // Process content with special blocks
                processMessageWithSpecialBlocks(content, holder, message)
            } else {
                // Use text response for other parts
                val formattedText = formatTextWithoutCodeBlocks(content, holder.itemView.context)

                // Make sure regular text view has content
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = formattedText
                }

                // Set timestamp
                holder.setTimestamp(message.timestamp)
            }

            // Process images
            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE

                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Loading from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(RequestOptions()
                                .diskCacheStrategy(DiskCacheStrategy.ALL)
                                .error(R.drawable.ic_error_placeholder))
                            .into(imageView)
                            .clearOnDetach()

                        progressBar.visibility = View.GONE

                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base 64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image data
                                val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try decoding directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            }
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()

            // Fallback to text binding
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = message.content ?: ""
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = getItem(position)
        return when {
            message.type == MessageType.USER -> VIEW_TYPE_USER
            message.type == MessageType.BOT && message.containsImage -> VIEW_TYPE_BOT_WITH_IMAGE
            message.type == MessageType.BOT -> VIEW_TYPE_BOT
            else -> VIEW_TYPE_ERROR
        }
    }

    // Function to notify adapter that theme has changed
    fun notifyThemeChanged() {
        Log.d(THEME_TAG, "Theme changed, notifying adapter...")
        notifyDataSetChanged()  // Force redraw of all items with new theme
    }
    
    // Directly style the user message in the adapter
    private fun styleUserMessage(view: View, context: Context) {
        val theme = themeManager?.getCurrentTheme() ?: ThemeManager.THEME_LIGHT
        Log.d(THEME_TAG, "Styling user message with theme: $theme")
        val cardView = view as? CardView
        val messageContent = view.findViewById<TextView>(R.id.message_content)
        val timestamp = view.findViewById<TextView>(R.id.message_timestamp)
        
        // Apply theme colors based on the selected theme
        when (theme) {
            ThemeManager.THEME_LIGHT -> {
                // Light theme (dark grey background, white text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.light_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.light_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.light_user_msg_text))
            }
            ThemeManager.THEME_DARK -> {
                // Dark theme (white background, black text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.dark_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.dark_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.dark_user_msg_text))
            }
            ThemeManager.THEME_BROWN -> {
                // Brown theme (dark brown background, light khaki text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.brown_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.brown_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.brown_user_msg_text))
            }
            ThemeManager.THEME_YELLOW -> {
                // Yellow theme (dark yellow background, light yellow text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.yellow_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.yellow_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.yellow_user_msg_text))
            }
            ThemeManager.THEME_RED -> {
                // Red theme (dark red/wine red background, light pink text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.red_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.red_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.red_user_msg_text))
            }
            ThemeManager.THEME_GREEN -> {
                // Green theme (dark green/british racing green background, light green text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.green_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.green_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.green_user_msg_text))
            }
            ThemeManager.THEME_PURPLE -> {
                // Purple theme (dark purple background, light purple text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.purple_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.purple_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.purple_user_msg_text))
            }
            ThemeManager.THEME_CYAN -> {
                // Cyan theme (dark cyan/blue background, light cyan text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.cyan_user_msg_bg))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.cyan_user_msg_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.cyan_user_msg_text))
            }
        }
    }
    
    private fun styleBotMessage(view: View, context: Context) {
        val theme = themeManager?.getCurrentTheme() ?: ThemeManager.THEME_LIGHT
        Log.d(THEME_TAG, "Styling bot message with theme: $theme")
        val cardView = view as? CardView
        val messageContent = view.findViewById<TextView>(R.id.message_content)
        val timestamp = view.findViewById<TextView>(R.id.message_timestamp)
        
        // Apply theme colors based on the selected theme
        when (theme) {
            ThemeManager.THEME_LIGHT -> {
                // Light theme (white background, black text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.light_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.light_text))
                timestamp?.setTextColor(Color.GRAY)
            }
            ThemeManager.THEME_DARK -> {
                // Dark theme (black background, white text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.dark_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.dark_text))
                timestamp?.setTextColor(Color.LTGRAY)
            }
            ThemeManager.THEME_BROWN -> {
                // Brown theme (light khaki background, dark brown text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.brown_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.brown_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.brown_text))
            }
            ThemeManager.THEME_YELLOW -> {
                // Yellow theme (light yellow background, dark yellow text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.yellow_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.yellow_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.yellow_text))
            }
            ThemeManager.THEME_RED -> {
                // Red theme (light pink background, dark red/wine red text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.red_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.red_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.red_text))
            }
            ThemeManager.THEME_GREEN -> {
                // Green theme (light green background, dark green/british racing green text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.green_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.green_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.green_text))
            }
            ThemeManager.THEME_PURPLE -> {
                // Purple theme (light purple background, dark purple text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.purple_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.purple_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.purple_text))
            }
            ThemeManager.THEME_CYAN -> {
                // Cyan theme (light cyan background, dark cyan/blue text)
                cardView?.setCardBackgroundColor(ContextCompat.getColor(context, R.color.cyan_background))
                messageContent?.setTextColor(ContextCompat.getColor(context, R.color.cyan_text))
                timestamp?.setTextColor(ContextCompat.getColor(context, R.color.cyan_text))
            }
        }
    }
    
    private fun styleErrorMessage(view: View, context: Context) {
        // Error messages should remain red for visibility regardless of theme
        // But we might adjust the shade based on the theme
        val messageContent = view.findViewById<TextView>(R.id.message_content)
        val timestamp = view.findViewById<TextView>(R.id.message_timestamp)
        
        messageContent?.setTextColor(Color.WHITE)
        messageContent?.setBackgroundResource(R.drawable.bg_message_error)
        
        // Timestamp can be themed
        val theme = themeManager?.getCurrentTheme() ?: ThemeManager.THEME_LIGHT
        when (theme) {
            ThemeManager.THEME_DARK -> timestamp?.setTextColor(Color.LTGRAY)
            else -> timestamp?.setTextColor(Color.GRAY)
        }
    }

    // Checks if the message contains a markdown table
    private fun containsMarkdownTable(text: String): Boolean {
        val pattern = Pattern.compile("\\|(.+?)\\|[\\s\\S]*?\\|", Pattern.DOTALL)
        val matcher = pattern.matcher(text)
        return matcher.find()
    }

    // Process message with special blocks (code blocks and tables)
    private fun processMessageWithSpecialBlocks(messageText: String, holder: MessageViewHolder, message: Message) {
        try {
            // Hide the regular Content TextView since we'll be using the container
            holder.getContentTextView()?.visibility = View.GONE

            // Get the content container
            val contentContainer = holder.getContentContainer()
            if (contentContainer == null) {
                Log.e(TAG, "Content container not found in layout")
                // Fallback to regular TextView if container not found
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = messageText
                }
                holder.setTimestamp(message.timestamp)
                return
            }

            // Make container visible
            contentContainer.visibility = View.VISIBLE

            // Clear content container
            contentContainer.removeAllViews()

            // Find all code blocks
            val codeBlocks = findCodeBlocks(messageText)
            Log.d(TAG, "Found ${codeBlocks.size} code blocks in message")

            // Find all table blocks
            val tableBlocks = findTableBlocks(messageText)
            Log.d(TAG, "Found ${tableBlocks.size} table blocks in message")

            // Combine both types of blocks and sort by position
            val allBlocks = (codeBlocks + tableBlocks).sortedBy { it.startPosition }

            if (allBlocks.isEmpty()) {
                // If no special blocks are found, format text normally
                val formattedText = formatTextWithoutCodeBlocks(messageText, holder.itemView.context)
                val textView = createTextView(holder.itemView.context, formattedText)
                contentContainer.addView(textView)
            } else {
                var lastPosition = 0

                for (block in allBlocks) {
                    // Add text before the block
                    if (block.startPosition > lastPosition) {
                        val textBefore = messageText.substring(lastPosition, block.startPosition)
                        if (textBefore.isNotEmpty()) {
                            val formattedText = formatTextWithoutCodeBlocks(textBefore, holder.itemView.context)
                            val textView = createTextView(holder.itemView.context, formattedText)
                            contentContainer.addView(textView)
                        }
                    }

                    // Add the block based on its type
                    if (block.language == "table") {
                        // This is a table block
                        val tableView = processMarkdownTable(block.code, holder.itemView.context)
                        contentContainer.addView(tableView)
                    } else {
                        // This is a code block
                        val codeBlockView = createCodeBlockView(
                            holder.itemView.context,
                            block.language,
                            block.code
                        )
                        contentContainer.addView(codeBlockView)
                    }

                    // Update last position
                    lastPosition = block.endPosition
                }

                // Add remaining text after the last block
                if (lastPosition < messageText.length) {
                    val textAfter = messageText.substring(lastPosition)
                    if (textAfter.isNotEmpty()) {
                        val formattedText = formatTextWithoutCodeBlocks(textAfter, holder.itemView.context)
                        val textView = createTextView(holder.itemView.context, formattedText)
                        contentContainer.addView(textView)
                    }
                }
            }

            // Set the timestamp
            holder.setTimestamp(message.timestamp)

            // Hide the old code blocks container
            holder.getCodeBlocksContainer()?.visibility = View.GONE

        } catch (e: Exception) {
            Log.e(TAG, "Error processing message with special blocks: ${e.message}")
            e.printStackTrace()

            // Fallback to simple TextView
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = messageText
            }
            holder.setTimestamp(message.timestamp)
        }
    }



    // Advanced table detection to better handle specific table format
    private fun findTableBlocks(text: String): List<CodeBlock> {
        val tableBlocks = mutableListOf<CodeBlock>()

        try {
            // Pattern for standard markdown tables (header row, separator row, data rows)
            val tablePattern = Pattern.compile(
                "^\\|(.+?)\\|\\s*\\n" +  // Header row
                "\\|([-:]+\\|[-:\\s|]+)+\\s*\\n" +  // Separator row
                "(\\|.+?\\|\\s*\\n)+",  // Data rows
                Pattern.MULTILINE
            )
            val matcher = tablePattern.matcher(text)

            // First check for standard tables
            while (matcher.find()) {
                val tableText = matcher.group(0) ?: continue  
                if (!isPositionInsideCodeBlock(text, matcher.start())) {
                    tableBlocks.add(
                        CodeBlock(
                            language = "table",
                            code = tableText.trim(),
                            startPosition = matcher.start(),
                            endPosition = matcher.end()
                        )
                    )
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding table blocks: ${e.message}")
            e.printStackTrace()
        }

        return tableBlocks
    }

    // Helper method to check if a position in text is inside a code block
    private fun isPositionInsideCodeBlock(text: String, position: Int): Boolean {
        val codeBlockPattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
        val matcher = codeBlockPattern.matcher(text)

        while (matcher.find()) {
            if (position >= matcher.start() && position <= matcher.end()) {
                return true
            }
        }

        return false
    }

    private fun findCodeBlocks(text: String): List<CodeBlock> {
        val codeBlocks = mutableListOf<CodeBlock>()
    
        // Finding match for code blocks with language identifier, now handling C++
        try {
            // Updated pattern to better match language identifiers including C++
            val pattern = Pattern.compile("```([a-zA-Z+]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
            val matcher = pattern.matcher(text)

            while (matcher.find()) {
                val language = matcher.group(1) ?: ""
                var codeContent = matcher.group(2) ?: ""

                // Handle escaped newlines in the code content
                if (codeContent.contains("\\n")) {
                    codeContent = codeContent.replace("\\n", "\n")
                }

                Log.d(TAG, "Found code block: language=$language, position=${matcher.start()}-${matcher.end()}")

                codeBlocks.add(
                    CodeBlock(
                        language = language,
                        code = codeContent.trim(),
                        startPosition = matcher.start(),
                        endPosition = matcher.end()
                    )    
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding code blocks: ${e.message}.")
            e.printStackTrace()
        }
        return codeBlocks
    }




    // Helper function for table styling - adjusts color brightness
    private fun adjustBrightness(colorHex: String, percent: Int): String {
        try {
            // Remove the # if present
            val cleanHex = if (colorHex.startsWith("#")) colorHex.substring(1) else colorHex
            
            // Parse the color
            val color = Color.parseColor("#$cleanHex")
            
            // Get RGB components
            val r = Color.red(color)
            val g = Color.green(color)
            val b = Color.blue(color)
            
            // Adjust brightness
            val adjustedR = (r * (100 + percent) / 100).coerceIn(0, 255)
            val adjustedG = (g * (100 + percent) / 100).coerceIn(0, 255)
            val adjustedB = (b * (100 + percent) / 100).coerceIn(0, 255)
            
            // Format new color
            return String.format("#%02X%02X%02X", adjustedR, adjustedG, adjustedB)
        } catch (e: Exception) {
            // In case of error, return the original color or a fallback
            return colorHex
        }
    }


    private fun processMarkdownTable(tableText: String, context: Context): View {
        return try {
            Log.d(TAG, "Processing markdown table: ${tableText.take(50)}...")
            
            // Initialize theme manager if needed
            if (themeManager == null) {
                themeManager = ThemeManager(context)
            }
            
            // Get theme colors from ThemeManager
            val tableColors = themeManager?.getTableColors() ?: return TextView(context).apply {
                text = "Table rendering failed: No theme manager available"
            }
            
            // Use the retrieved colors
            val tableBgColor = tableColors.backgroundColor
            val tableHeaderBgColor = tableColors.headerBackgroundColor
            val tableBorderColor = tableColors.borderColor
            val tableTextColor = tableColors.textColor
            val alternateRowColor = tableColors.alternateRowColor
            
            // 1. Create container for table and button
            val container = LinearLayout(context).apply {
                orientation = LinearLayout.VERTICAL
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
                setBackgroundColor(tableBgColor)
                setPadding(0, 8.dpToPx(context), 0, 8.dpToPx(context))
            }

            // 2. Create header bar with copy button
            val headerBar = LinearLayout(context).apply {
                orientation = LinearLayout.HORIZONTAL
                setBackgroundColor(tableHeaderBgColor)
                setPadding(8.dpToPx(context), 8.dpToPx(context), 8.dpToPx(context), 8.dpToPx(context))
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
            }

            // Add table label
            headerBar.addView(TextView(context).apply {
                text = "TABLE"
                setTypeface(null, Typeface.BOLD)
                setTextColor(tableTextColor)
            })

            // Add spacer
            headerBar.addView(View(context).apply {
                layoutParams = LinearLayout.LayoutParams(0, 1, 1f)
            })

            // Add copy button
            headerBar.addView(Button(context, null, 0, R.style.CopyButtonStyle).apply {
                text = "Copy"
                setTextColor(tableTextColor)

                //copyIcon.setImageResource(R.drawable.ic_copy)
                //copyIcon.setColorFilter(textColor)

                setBackgroundColor(alternateRowColor)

                gravity = Gravity.CENTER
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    40.dpToPx(context)
                ).apply {
                    gravity = Gravity.CENTER_VERTICAL
                }
          

                setOnClickListener {
                    val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                    val clip = ClipData.newPlainText("Table", tableText)
                    clipboard.setPrimaryClip(clip)
                    Toast.makeText(context, "Table copied", Toast.LENGTH_SHORT).show()
                }
            })

            // 3. Convert markdown table to HTML with theme colors
            val htmlTable = convertMarkdownTableToHtml(
                tableText,
                context,
                tableBorderColor,
                tableHeaderBgColor,
                tableTextColor,
                alternateRowColor
            )
            Log.d(TAG, "Converted HTML table:\n$htmlTable")

            // 4. Create WebView with optimized settings
            val webView = WebView(context).apply {
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                ).apply {
                    height = ViewGroup.LayoutParams.WRAP_CONTENT
                }

                settings.apply {
                    javaScriptEnabled = false
                    loadWithOverviewMode = true
                    useWideViewPort = true
                    layoutAlgorithm = WebSettings.LayoutAlgorithm.TEXT_AUTOSIZING
                    setSupportZoom(false)
                    builtInZoomControls = false
                    displayZoomControls = false
                    cacheMode = WebSettings.LOAD_NO_CACHE
                }

                isVerticalScrollBarEnabled = false
                isHorizontalScrollBarEnabled = true
                setBackgroundColor(Color.TRANSPARENT)
                setLayerType(View.LAYER_TYPE_HARDWARE, null)
            }

            // 5. Create HTML document with responsive styling and theme colors
            val borderColorHex = String.format("#%06X", 0xFFFFFF and tableBorderColor)
            val headerBgColorHex = String.format("#%06X", 0xFFFFFF and tableHeaderBgColor)
            val textColorHex = String.format("#%06X", 0xFFFFFF and tableTextColor)
            val bgColorHex = String.format("#%06X", 0xFFFFFF and tableBgColor)
            val alternateRowColorHex = String.format("#%06X", 0xFFFFFF and alternateRowColor)
            
            val html = """
            <!DOCTYPE html>
            <html>
            <head>
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body {
                        margin: 0;
                        padding: 0;
                        width: 100%;
                        background-color: transparent;
                        color: $textColorHex;
                    }
                    table {
                        border-collapse: collapse;
                        width: 100%;
                        margin: 0;
                        padding: 0;
                    }
                    th, td {
                        border: 1px solid $borderColorHex;
                        padding: 8px;
                        text-align: left;
                        color: $textColorHex;
                    }
                    th {
                        background-color: $headerBgColorHex;
                        position: sticky;
                        top: 0;
                    }
                    tr:nth-child(even) {
                        background-color: $bgColorHex;
                    }
                    tr:nth-child(odd):not(:first-child) {
                        background-color: $alternateRowColorHex;
                    }
                </style>
            </head>
            <body>
                $htmlTable
            </body>
            </html>
            """.trimIndent()

            // 6. Create scroll container
            val scrollView = HorizontalScrollView(context).apply {
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
                overScrollMode = View.OVER_SCROLL_ALWAYS
                isFillViewport = true
            }

            // 7. Load HTML into WebView
            webView.loadDataWithBaseURL(
                null, 
                html,
                "text/html", 
                "UTF-8", 
                null
            )

            // 8. Add views to container
            scrollView.addView(webView)
            container.addView(headerBar)
            container.addView(scrollView)

            container
        } catch (e: Exception) {
            Log.e(TAG, "Error rendering table", e)
            TextView(context).apply {
                text = "Table rendering failed. Raw content:\n\n$tableText"
            }
        }
    }


    // Convert markdown table to HTML with theme colors
    private fun convertMarkdownTableToHtml(
        markdownTable: String, 
        context: Context,
        borderColor: Int = Color.parseColor("#dee2e6"),
        headerBgColor: Int = Color.parseColor("#e9ecef"),
        textColor: Int = Color.BLACK,
        alternateRowColor: Int = Color.parseColor("#f5f5f5")
    ): String {
        try {
            val lines = markdownTable.trim().split("\n")
                .map { it.trim() }
                .filter { it.isNotEmpty() && it.startsWith("|") }

            if (lines.size < 2) return "<p>Invalid table format</p>"

            // Format colors as hex
            val borderColorHex = String.format("#%06X", 0xFFFFFF and borderColor)
            val headerBgColorHex = String.format("#%06X", 0xFFFFFF and headerBgColor)
            val textColorHex = String.format("#%06X", 0xFFFFFF and textColor)
            val alternateRowColorHex = String.format("#%06X", 0xFFFFFF and alternateRowColor)

            val html = StringBuilder().apply {
                append("<table style=\"border-collapse: collapse; width: 100%;\">")
                
                // Process header row
                append("<tr style=\"background-color: $headerBgColorHex;\">")
                lines[0].trim('|').split("|")
                    .map { it.trim() }
                    .forEach { cell ->
                        append("<th style=\"border: 1px solid $borderColorHex; padding: 8px; color: $textColorHex;\">")
                        append(processCellContent(cell, context))
                        append("</th>")
                    }
                append("</tr>")
                
                // Process data rows with alternating colors
                lines.drop(2).forEachIndexed { index, line ->
                    val bgColor = if (index % 2 == 0) {
                        alternateRowColorHex // Odd rows get alternate color
                    } else {
                        // Even rows stay with normal background
                        String.format("#%06X", 0xFFFFFF and borderColor)
                    }
                    
                    append("<tr style=\"background-color: $bgColor;\">")
                    line.trim('|').split("|")
                        .map { it.trim() }
                        .forEach { cell ->
                            append("<td style=\"border: 1px solid $borderColorHex; padding: 8px; color: $textColorHex;\">")
                            append(processCellContent(cell, context))
                            append("</td>")
                        }
                    append("</tr>")
                }
                
                append("</table>")
            }
            
            return html.toString()
        } catch (e: Exception) {
            Log.e(TAG, "Error converting table to HTML", e)
            return "<p>Error processing table</p>"
        }
    }
    // Process cell content for tables
    private fun processCellContent(cellText: String, context: Context): String {
        val processedText = cellText
            .replace(Regex("(?m)^(#{1,3})\\s+([^\\n]+)")) { matchResult ->
                val headerLevel = matchResult.groupValues[1].length
                val headerText = matchResult.groupValues[2]
                
                // Create different HTML based on header level
                when (headerLevel) {
                    1 -> "<h1 style=\"font-size: ${18.dpToPx(context)}px; margin: 4px 0; font-weight: bold;\">$headerText</h1>"
                    2 -> "<h2 style=\"font-size: ${16.dpToPx(context)}px; margin: 3px 0; font-weight: bold;\">$headerText</h2>"
                    3 -> "<h3 style=\"font-size: ${14.dpToPx(context)}px; margin: 2px 0; font-weight: bold;\">$headerText</h3>"
                    else -> headerText
                }
            }
            .replace(Regex("\\*\\*(.*?)\\*\\*", RegexOption.DOT_MATCHES_ALL)) { "<strong>${it.groupValues[1]}</strong>" }
            .replace(Regex("\\*(.*?)\\*", RegexOption.DOT_MATCHES_ALL)) { "<em>${it.groupValues[1]}</em>" }
            .replace(Regex("_(.*?)_", RegexOption.DOT_MATCHES_ALL)) { "<em>${it.groupValues[1]}</em>" }
            .replace(Regex("`(.*?)`", RegexOption.DOT_MATCHES_ALL)) { 
                "<code style=\"background: #f5f5f5; padding: 2px 4px; border-radius: 3px;\">${it.groupValues[1]}</code>" 
            }
            .replace(Regex("^\\* ")) { "• " }
        
        return processedText
    }



    private fun createCodeBlockView(
        context: Context,
        language: String,
        code: String
    ): View {
        try {
            // Initialize ThemeManager if needed
            if (themeManager == null) {
                themeManager = ThemeManager(context)
            }
            
            // Get code block colors from ThemeManager
            val codeColors = themeManager?.getCodeBlockColors() ?: return TextView(context).apply {
                text = code
                typeface = Typeface.MONOSPACE
            }
            
            // Use the retrieved colors
            val bgColor = codeColors.backgroundColor
            val headerBgColor = codeColors.headerBackgroundColor
            val textColor = codeColors.textColor
            val headerTextColor = codeColors.headerTextColor
            val colorTheme = codeColors.colorTheme
            val buttonColor = codeColors.buttonColor
            
            // Inflate code block layout
            val codeBlockView = LayoutInflater.from(context)
                .inflate(R.layout.item_code_block, null, false)

            // Set layout parameters
            codeBlockView.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            // Get views
            val languageLabel = codeBlockView.findViewById<TextView>(R.id.code_language_label)
            val copyLayout = codeBlockView.findViewById<LinearLayout>(R.id.copy_layout)
            val copyIcon = codeBlockView.findViewById<ImageView>(R.id.copy_icon)
            val copyText = codeBlockView.findViewById<TextView>(R.id.copy_text)
            val codeView = codeBlockView.findViewById<CodeView>(R.id.code_view)

            if (languageLabel == null || copyLayout == null || copyIcon == null || 
                copyText == null || codeView == null) {
                Log.e(TAG, "Missing views in code block layout")
                return createFallbackCodeView(context, code)
            }
            
            // Set header background color
            val headerContainer = codeBlockView.findViewById<View>(R.id.code_block_header)
            headerContainer?.setBackgroundColor(headerBgColor)
            
            // Apply colors to views
            languageLabel.setTextColor(textColor)
            copyText.setTextColor(textColor)
            
            // Create dynamic button background using theme colors
            val buttonBg = GradientDrawable().apply {
                shape = GradientDrawable.RECTANGLE
                cornerRadius = 4 * context.resources.displayMetrics.density // Fix: Use direct calculation instead of extension
                
                // Use a slightly darker version of the header background for button background
                // This creates better visual contrast
                //val buttonColor = adjustColorBrightness(buttonColor, 0f)
                setColor(buttonColor)
                
                // Create a border using a brighter version of the header text color with transparency
                setStroke((1 * context.resources.displayMetrics.density).toInt(), 
                         ColorUtils.setAlphaComponent(headerTextColor, 130))
            }
            copyLayout.background = buttonBg
            
            // Set icon color and resource
            copyIcon.setImageResource(R.drawable.ic_copy)
            copyIcon.setColorFilter(textColor)
            //headerTextColor

            // Set language label
            val displayLanguage = when {
                language.equals("c++", ignoreCase = true) -> "C++"
                language.isNotEmpty() -> language
                else -> "plaintext"
            }
            languageLabel.text = displayLanguage

            // Set up copy functionality
            copyLayout.setOnClickListener {
                val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Code Snippet", code)
                clipboard.setPrimaryClip(clip)
                Toast.makeText(context, "Code copied to clipboard", Toast.LENGTH_SHORT).show()
                
                // Visual feedback animation when button is clicked
                val originalBackground = copyLayout.background
                
                // Create highlighted background for click effect
                val highlightBg = GradientDrawable().apply {
                    shape = GradientDrawable.RECTANGLE
                    cornerRadius = 4 * context.resources.displayMetrics.density // Fix: Use direct calculation
                    setColor(ColorUtils.setAlphaComponent(headerTextColor, 80))
                }
                
                copyLayout.background = highlightBg
                
                // Restore original background after a short delay
                Handler(Looper.getMainLooper()).postDelayed({
                    copyLayout.background = originalBackground
                }, 150)
            }

            // Configure code view with syntax highlighting
            try {
                val actualLanguage = if (language.isEmpty()) "text" else language
                
                // Use the theme color from ThemeManager
                codeView.setOptions(Options.Default.get(context)
                    .withLanguage(actualLanguage)
                    .withTheme(colorTheme)
                    .withCode(code))
                    
                // Try to access the internal text view if possible to set colors
                try {
                    val textViewField = CodeView::class.java.getDeclaredField("textView")
                    textViewField.isAccessible = true
                    val textView = textViewField.get(codeView) as? TextView
                    textView?.setTextColor(textColor)
                } catch (e: Exception) {
                    Log.e(TAG, "Error accessing CodeView internals: ${e.message}")
                }
                
                // Set background color
                codeView.setBackgroundColor(bgColor)
            } catch (e: Exception) {
                Log.e(TAG, "Error setting code options: ${e.message}")
                codeView.setCode(code)
            }
            
            return codeBlockView
        } catch (e: Exception) {
            Log.e(TAG, "Error creating code block view: ${e.message}")
            e.printStackTrace()
            return createFallbackCodeView(context, code)
        }
    }

    // Helper function to adjust color brightness
    private fun adjustColorBrightness(color: Int, factor: Float): Int {
        val a = Color.alpha(color)
        val r = (Color.red(color) * factor).toInt().coerceIn(0, 255)
        val g = (Color.green(color) * factor).toInt().coerceIn(0, 255)
        val b = (Color.blue(color) * factor).toInt().coerceIn(0, 255)
        return Color.argb(a, r, g, b)
    }

    // Extension function to convert dp to pixels
    private fun Int.dpToPx(context: Context): Int {
        return (this * context.resources.displayMetrics.density).toInt()
    }

    // Helper method for creating fallback code view
    private fun createFallbackCodeView(context: Context, code: String): TextView {
        // Initialize ThemeManager if needed
        if (themeManager == null) {
            themeManager = ThemeManager(context)
        }
        
        // Get code block colors from ThemeManager
        val codeColors = themeManager?.getCodeBlockColors()
        
        // Determine colors based on theme or use defaults
        val bgColor = codeColors?.backgroundColor ?: Color.parseColor("#f0f0f0")
        val textColor = codeColors?.textColor ?: Color.parseColor("#212121")
        
        return TextView(context).apply {
            text = code
            typeface = Typeface.MONOSPACE
            setPadding(16, 16, 16, 16)
            setBackgroundColor(bgColor)
            setTextColor(textColor)
        }
    }

    // Update createTextView to use ThemeManager for styling
    private fun createTextView(context: Context, text: SpannableString): TextView {
        val textView = TextView(context)
        textView.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        textView.textSize = 16f
        textView.text = text
        
        // Apply theme-specific text color from ThemeManager
        if (themeManager == null) {
            themeManager = ThemeManager(context)
        }
        
        val currentTheme = themeManager?.getCurrentTheme() ?: ThemeManager.THEME_LIGHT
        
        // Set text color based on current theme
        when (currentTheme) {
            ThemeManager.THEME_LIGHT -> textView.setTextColor(ContextCompat.getColor(context, R.color.light_text))
            ThemeManager.THEME_DARK -> textView.setTextColor(ContextCompat.getColor(context, R.color.dark_text))
            ThemeManager.THEME_BROWN -> textView.setTextColor(ContextCompat.getColor(context, R.color.brown_text))
            ThemeManager.THEME_YELLOW -> textView.setTextColor(ContextCompat.getColor(context, R.color.yellow_text))
            ThemeManager.THEME_RED -> textView.setTextColor(ContextCompat.getColor(context, R.color.red_text))
            ThemeManager.THEME_GREEN -> textView.setTextColor(ContextCompat.getColor(context, R.color.green_text))
            ThemeManager.THEME_PURPLE -> textView.setTextColor(ContextCompat.getColor(context, R.color.purple_text))
            ThemeManager.THEME_CYAN -> textView.setTextColor(ContextCompat.getColor(context, R.color.cyan_text))
        }
        
        return textView
    }


    // Format text without code blocks - with theme-aware styling
    private fun formatTextWithoutCodeBlocks(text: String, context: Context): SpannableString {
        try {
            // Process bullet points (convert * to •)
            val bulletPattern = Pattern.compile("(?m)^\\s*\\* ")
            val bulletMatcher = bulletPattern.matcher(text)
            val bulletText = bulletMatcher.replaceAll("• ")

            // Find all formatting elements and their positions
            val formattingRanges = mutableListOf<FormattingRange>()
            
            // Find headers and add newline after them
            val headerPattern = Pattern.compile("(?m)^(#{1,3})\\s+([^\\n]+)")
            val headerMatcher = headerPattern.matcher(bulletText)
            val textWithHeaders = StringBuilder(bulletText)
            
            // We need to track offset as we add newlines
            var headerOffset = 0
            
            while (headerMatcher.find()) {
                val headerMarker = headerMatcher.group(1) ?: ""
                val headerContent = headerMatcher.group(2) ?: ""
                val markerStart = headerMatcher.start() + headerOffset
                val markerEnd = headerMatcher.start(2) + headerOffset // Start of header text
                val contentEnd = headerMatcher.end() + headerOffset
                
                // Check if there's already a newline after the header
                val hasNewline = contentEnd < textWithHeaders.length && textWithHeaders[contentEnd] == '\n'
                
                if (!hasNewline) {
                    // Add a newline after the header
                    textWithHeaders.insert(contentEnd, "\n")
                    headerOffset += 1 // Increment offset for subsequent headers
                }
                
                formattingRanges.add(
                    FormattingRange(
                        markerStart, markerEnd, contentEnd,
                        FormattingType.HEADER, headerMarker.length
                    )
                )
            }
            
            // Use the updated text with newlines after headers
            val processedText = textWithHeaders.toString()
            
            // Find bold text (**text**)
            val boldPattern = Pattern.compile("\\*\\*(.*?)\\*\\*", Pattern.DOTALL)
            val boldMatcher = boldPattern.matcher(processedText)
            while (boldMatcher.find()) {
                formattingRanges.add(
                    FormattingRange(
                        boldMatcher.start(), boldMatcher.start() + 2,
                        boldMatcher.end() - 2, FormattingType.BOLD
                    )
                )
            }
            
            // Find italic text with asterisks (*text*) - but not if it's part of **bold**
            val italicAsteriskPattern = Pattern.compile("\\*(.*?)\\*", Pattern.DOTALL)
            val italicAsteriskMatcher = italicAsteriskPattern.matcher(processedText)
            while (italicAsteriskMatcher.find()) {
                // Check if this is not part of a bold marker
                val isPartOfBold = formattingRanges.any { range -> 
                    range.type == FormattingType.BOLD && 
                    (italicAsteriskMatcher.start() >= range.markerStart && 
                     italicAsteriskMatcher.end() <= range.contentEnd + 4) // +4 to include both ** markers
                }
                
                if (!isPartOfBold) {
                    formattingRanges.add(
                        FormattingRange(
                            italicAsteriskMatcher.start(), italicAsteriskMatcher.start() + 1,
                            italicAsteriskMatcher.end() - 1, FormattingType.ITALIC
                        )
                    )
                }
            }
            
            // Find italic text with underscores (_text_)
            val italicUnderscorePattern = Pattern.compile("_(.*?)_", Pattern.DOTALL)
            val italicUnderscoreMatcher = italicUnderscorePattern.matcher(processedText)
            while (italicUnderscoreMatcher.find()) {
                formattingRanges.add(
                    FormattingRange(
                        italicUnderscoreMatcher.start(), italicUnderscoreMatcher.start() + 1,
                        italicUnderscoreMatcher.end() - 1, FormattingType.ITALIC
                    )
                )
            }

            // Find inline code
            val inlineCodePattern = Pattern.compile("`(.*?)`", Pattern.DOTALL)
            val inlineCodeMatcher = inlineCodePattern.matcher(processedText)
            while (inlineCodeMatcher.find()) {
                formattingRanges.add(
                    FormattingRange(
                        inlineCodeMatcher.start(), inlineCodeMatcher.start() + 1,
                        inlineCodeMatcher.end() - 1, FormattingType.CODE
                    )
                )
            }
            
            // Build text without markers
            val builder = StringBuilder()
            val spans = mutableListOf<FormattedSpan>()
            var lastIndex = 0
            
            // Sort by start position to process in order
            val sortedRanges = formattingRanges.sortedBy { it.markerStart }
            
            // This map tracks which parts of the text have already been processed
            // to avoid duplicating content
            val processedRanges = mutableListOf<Pair<Int, Int>>()
            
            for (range in sortedRanges) {
                // Check if this range overlaps with any already processed ranges
                val overlaps = processedRanges.any { (start, end) ->
                    (range.markerStart <= end && range.contentEnd + (range.markerEnd - range.markerStart) >= start)
                }
                
                if (overlaps) {
                    // Skip this range as it would cause duplication
                    continue
                }
                
                // Add any text before this formatting element
                if (range.markerStart > lastIndex) {
                    builder.append(processedText.substring(lastIndex, range.markerStart))
                }
                
                // Get the content without the markers
                val content = processedText.substring(range.markerEnd, range.contentEnd)
                
                // Record where this content will be in our final string
                val spanStart = builder.length
                builder.append(content)
                val spanEnd = builder.length
                
                // Record the span to apply later
                spans.add(FormattedSpan(spanStart, spanEnd, range.type, range.level))
                
                // Update last index to after this formatting element (including end marker)
                lastIndex = range.contentEnd + (range.markerEnd - range.markerStart)
                
                // Mark this range as processed
                processedRanges.add(Pair(range.markerStart, lastIndex))
            }
            
            // Add any remaining text
            if (lastIndex < processedText.length) {
                builder.append(processedText.substring(lastIndex))
            }
            
            // Create the SpannableString
            val result = SpannableString(builder.toString())
            
            // Apply all the spans with theme-aware colors
            val currentTheme = themeManager?.getCurrentTheme() ?: ThemeManager.THEME_LIGHT
            Log.d(THEME_TAG, "Formatting text with theme: $currentTheme")
            
            for (span in spans) {
                when (span.type) {
                    FormattingType.HEADER -> {
                        // Apply header styling based on level
                        when (span.level) {
                            1 -> { // # - Largest header
                                result.setSpan(
                                    RelativeSizeSpan(1.5f),
                                    span.start, span.end,
                                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                result.setSpan(
                                    StyleSpan(Typeface.BOLD),
                                    span.start, span.end,
                                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                
                                // Apply theme-specific color
                                when (currentTheme) {
                                    ThemeManager.THEME_DARK -> {
                                        result.setSpan(
                                            ForegroundColorSpan(Color.WHITE),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_BROWN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.brown_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_YELLOW -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.yellow_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_RED -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.red_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_GREEN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.green_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_PURPLE -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.purple_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_CYAN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.cyan_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                }
                            }
                            2 -> { // ## - Medium header
                                result.setSpan(
                                    RelativeSizeSpan(1.25f),
                                    span.start, span.end,
                                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                result.setSpan(
                                    StyleSpan(Typeface.BOLD),
                                    span.start, span.end,
                                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                
                                // Apply theme-specific color
                                when (currentTheme) {
                                    ThemeManager.THEME_DARK -> {
                                        result.setSpan(
                                            ForegroundColorSpan(Color.WHITE),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_BROWN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.brown_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_YELLOW -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.yellow_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_RED -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.red_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_GREEN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.green_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_PURPLE -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.purple_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_CYAN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.cyan_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                }
                            }
                            3 -> { // ### - Small header
                                result.setSpan(
                                    RelativeSizeSpan(1.1f),
                                    span.start, span.end,
                                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                result.setSpan(
                                    StyleSpan(Typeface.BOLD),
                                    span.start, span.end,
                                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                
                                // Apply theme-specific color
                                when (currentTheme) {
                                    ThemeManager.THEME_DARK -> {
                                        result.setSpan(
                                            ForegroundColorSpan(Color.WHITE),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_BROWN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.brown_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_YELLOW -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.yellow_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_RED -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.red_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_GREEN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.green_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_PURPLE -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.purple_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                    ThemeManager.THEME_CYAN -> {
                                        result.setSpan(
                                            ForegroundColorSpan(ContextCompat.getColor(context, R.color.cyan_text)),
                                            span.start, span.end,
                                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                                        )
                                    }
                                }
                            }
                        }
                    }
                    FormattingType.BOLD -> {
                        result.setSpan(
                            StyleSpan(Typeface.BOLD),
                            span.start, span.end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                    FormattingType.ITALIC -> {
                        result.setSpan(
                            StyleSpan(Typeface.ITALIC),
                            span.start, span.end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                    FormattingType.CODE -> {
                        // Get theme-specific colors for inline code
                        val bgColor: Int
                        val fgColor: Int
                        
                        when (currentTheme) {
                            ThemeManager.THEME_DARK -> {
                                bgColor = Color.parseColor("#2D2D2D")
                                fgColor = Color.parseColor("#CC7832")
                            }
                            ThemeManager.THEME_BROWN -> {
                                bgColor = ContextCompat.getColor(context, R.color.brown_dark)
                                fgColor = ContextCompat.getColor(context, R.color.brown_light)
                            }
                            ThemeManager.THEME_YELLOW -> {
                                bgColor = ContextCompat.getColor(context, R.color.yellow_dark)
                                fgColor = ContextCompat.getColor(context, R.color.yellow_light)
                            }
                            ThemeManager.THEME_RED -> {
                                bgColor = ContextCompat.getColor(context, R.color.red_dark)
                                fgColor = ContextCompat.getColor(context, R.color.red_light)
                            }
                            ThemeManager.THEME_GREEN -> {
                                bgColor = ContextCompat.getColor(context, R.color.green_dark)
                                fgColor = ContextCompat.getColor(context, R.color.green_light)
                            }
                            ThemeManager.THEME_PURPLE -> {
                                bgColor = ContextCompat.getColor(context, R.color.purple_dark)
                                fgColor = ContextCompat.getColor(context, R.color.purple_light)
                            }
                            ThemeManager.THEME_CYAN -> {
                                bgColor = ContextCompat.getColor(context, R.color.cyan_dark)
                                fgColor = ContextCompat.getColor(context, R.color.cyan_light)
                            }
                            else -> {
                                // Default light theme
                                bgColor = ContextCompat.getColor(context, R.color.inline_code_bg)
                                    ?: Color.parseColor("#f5f5f5")
                                fgColor = ContextCompat.getColor(context, R.color.inline_code_fg)
                                    ?: Color.parseColor("#e83e8c")
                            }
                        }
                                
                        // Apply formatting
                        result.setSpan(
                            BackgroundColorSpan(bgColor),
                            span.start, span.end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                        result.setSpan(
                            ForegroundColorSpan(fgColor),
                            span.start, span.end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                        result.setSpan(
                            TypefaceSpan("monospace"),
                            span.start, span.end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                }
            }
            
            return result
        } catch (e: Exception) {
            Log.e(TAG, "Error formatting text: ${e.message}")
            e.printStackTrace()
            return SpannableString(text)
        }
    }

    // Helper data classes for formatting
    private enum class FormattingType {
        HEADER, BOLD, ITALIC, CODE
    }

    private data class FormattingRange(
        val markerStart: Int,  // Start of the opening marker
        val markerEnd: Int,    // End of the opening marker (start of content)
        val contentEnd: Int,   // End of the content (start of closing marker)
        val type: FormattingType,
        val level: Int = 0     // Used for headers (1, 2, 3)
    )

    private data class FormattedSpan(
        val start: Int,
        val end: Int,
        val type: FormattingType,
        val level: Int = 0
    )

    // Data class to store block info (for both code and tables)
    private data class CodeBlock(
        val language: String,
        val code: String,
        val startPosition: Int,
        val endPosition: Int
    )

    // Helper method to darken a color for the header
    private fun darkenColor(color: Int): Int {
        val hsv = FloatArray(3)
        Color.colorToHSV(color, hsv)
        hsv[2] *= 0.8f // Reduce brightness to 80%
        return Color.HSVToColor(hsv)
    }

    
    private class MessageDiffCallback : DiffUtil.ItemCallback<Message>() {
        override fun areItemsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem.id == newItem.id
        }
        override fun areContentsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem == newItem
        }
    }

    companion object {
        const val VIEW_TYPE_USER = 0
        const val VIEW_TYPE_BOT = 1
        const val VIEW_TYPE_ERROR = 2
        const val VIEW_TYPE_BOT_WITH_IMAGE = 3
    }
}
 

