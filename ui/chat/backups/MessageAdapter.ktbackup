package com.example.lilotest.ui.chat

import android.text.SpannableString
import android.text.Spanned
import android.text.style.StyleSpan
import android.graphics.Typeface
import android.util.Log

import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.ImageView

import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions

import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType

import android.util.Base64
import android.view.View
import android.widget.ProgressBar
import java.util.regex.Pattern

class MessageAdapter : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {
    private val TAG = "MessageAdapter"

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {
        val layoutId = when (viewType) {
            VIEW_TYPE_USER -> R.layout.item_message_user
            VIEW_TYPE_BOT_WITH_IMAGE -> R.layout.item_message_bot_with_image
            VIEW_TYPE_BOT -> R.layout.item_message_bot
            else -> R.layout.item_message_error
        }

        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false) 
        return MessageViewHolder(view)
    }

    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)
        holder.bind(message, this::formatBoldText)

        // If image in text load the image
        if (message.containsImage) {
            val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
            val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

            if (imageView != null && progressBar != null) {
                Log.d(TAG, "Loading image for message: ${message.id}")
                progressBar.visibility = View.VISIBLE

                if (!message.imageUrl.isNullOrEmpty()) {
                    Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                    // Load from URL
                    Glide.with(holder.itemView.context)
                        .load(message.imageUrl)
                        .apply(RequestOptions()
                            .diskCacheStrategy(DiskCacheStrategy.ALL)
                            .error(R.drawable.ic_error_placeholder))
                        .into(imageView)
                        .clearOnDetach()

                    progressBar.visibility = View.GONE
                } else if (!message.imageData.isNullOrEmpty()) {
                    try {
                        Log.d(TAG, "Loading from base64 data")
                        if (message.imageData.startsWith("data:image")) {
                            // Parse image URL
                            val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                            val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                            Glide.with(holder.itemView.context)
                                .load(imageBytes)
                                .apply(RequestOptions()
                                    .diskCacheStrategy(DiskCacheStrategy.NONE)
                                    .error(R.drawable.ic_error_placeholder))
                                .into(imageView)
                                .clearOnDetach()
                        } else {
                            // Try to decode directly
                            val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)

                            Glide.with(holder.itemView.context)
                                .load(imageBytes)
                                .apply(RequestOptions()
                                    .diskCacheStrategy(DiskCacheStrategy.NONE)
                                    .error(R.drawable.ic_error_placeholder))
                                .into(imageView)
                                .clearOnDetach()
                        }
                        progressBar.visibility = View.GONE
                    } catch (e: Exception) {
                        Log.e(TAG, "Error loading base64 image: ${e.message}")
                        progressBar.visibility = View.GONE
                    }
                } else {
                    progressBar.visibility = View.GONE
                }
            }
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = getItem(position)
        return when {
            message.type == MessageType.USER -> VIEW_TYPE_USER
            message.type == MessageType.BOT && message.containsImage -> VIEW_TYPE_BOT_WITH_IMAGE
            message.type == MessageType.BOT -> VIEW_TYPE_BOT
            else -> VIEW_TYPE_ERROR
        }
    }

    // Format text with bold between asterisks
    private fun formatBoldText(text: String): SpannableString {

        val resultText = StringBuilder(text)

        val boldRanges = mutableListOf<Triple<Int, Int, Int>>()
        val pattern = Pattern.compile("\\*\\*(.*?)\\*\\*")
        val matcher = pattern.matcher(text)

        // Find all matches and replace with bold text
        var offset = 0
        while (matcher.find()) {
            val originalStart = matcher.start()
            val originalEnd = matcher.end()
            val innerText = matcher.group(1) ?: continue

            // Calculate positions in the modified text
            val adjustedStart = originalStart - offset
            val adjustedEnd = originalEnd - offset

            boldRanges.add(Triple(adjustedStart, adjustedStart + innerText.length, innerText.length))
            resultText.replace(adjustedStart, adjustedEnd, innerText)
            offset += 4
        }

        val spannableString = SpannableString(resultText.toString())

        for ((start, end, _) in boldRanges) {
            spannableString.setSpan(
                StyleSpan(Typeface.BOLD),
                start,
                end,
                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
            )
        }
        return spannableString
    }

    private class MessageDiffCallback : DiffUtil.ItemCallback<Message>() {
        override fun areItemsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem.id == newItem.id
        }
        override fun areContentsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem == newItem
        }
    }
    companion object {
        private const val VIEW_TYPE_USER = 0
        private const val VIEW_TYPE_BOT = 1
        private const val VIEW_TYPE_ERROR = 2
        private const val VIEW_TYPE_BOT_WITH_IMAGE = 3
    }
}