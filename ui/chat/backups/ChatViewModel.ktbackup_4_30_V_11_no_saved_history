package com.example.lilotest.ui.chat

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageThread
import com.example.lilotest.data.model.MessageType
import com.example.lilotest.data.model.MessageVersion
import com.example.lilotest.data.remote.MessageRepository
import com.example.lilotest.ui.chat.MessageTableLogger
import com.example.lilotest.data.remote.PromptBuilder
import kotlinx.coroutines.launch
import java.util.Date
import java.util.UUID
import android.util.Log

class ChatViewModel : ViewModel() {

    private val TAG = "ChatViewModel"
    private val repository = MessageRepository()

    private val _messages = MutableLiveData<List<Message>>(emptyList())
    val messages: LiveData<List<Message>> = _messages

    // Store message threads for version history
    private val messageThreads = mutableMapOf<String, MessageThread>()

    // Track the active thread for navigation operations
    private var activeThreadId: String? = null

    fun sendMessage(content: String) {
        val threadId = activeThreadId ?: UUID.randomUUID().toString()
        //val currentMessages = _messages.value?.toMutableList() ?: mutableListOf()

        // Create user message
        val userMessage = Message(
            id = System.currentTimeMillis().toString(),
            content = content,
            type = MessageType.USER,
            timestamp = Date(),
            threadId = threadId,
            versionNumber = 0
        )

        // Create thread to track versions
        val messageThread = messageThreads[threadId] ?: MessageThread(threadId).also {
            messageThreads[threadId] = it
        }
        val currentMessages = _messages.value?.toMutableList() ?: mutableListOf()

        // If new message in existing chain
        if (activeThreadId != null) {
            // Add to the active chain
            val chainId = messageThread.activeChainId
            if (chainId != null) {
                val chainMessage = userMessage.copy(chainId = chainId)
                messageThread.addMessageToActiveChain(chainMessage)
                // Add message to the visible messages list
                currentMessages.add(chainMessage)
                _messages.value = currentMessages.toList()
                Log.d(TAG, "Message added to the active/visible messages list: $currentMessages")
            } else { 
                // Create a new chain if needed
                val newChainId = messageThread.createNewChain()
                val chainMessage = userMessage.copy(chainId = newChainId)

                messageThread.addMessageToActiveChain(chainMessage)
                // Add user message to the active/visible messages list
                currentMessages.add(chainMessage)
                _messages.value = currentMessages.toList()
                Log.d(TAG, "User message added to the new chain: $newChainId")
            }
        } else {
            // This is a new thread
            messageThread.addVersion(userMessage)
            activeThreadId = threadId

            // Add user message to the visible messages list
            currentMessages.add(userMessage)
            _messages.value = currentMessages.toList()
            Log.d(TAG, "User message added to the new chain: $threadId")
        }

        // Send message to the server
        viewModelScope.launch {
            try {
                Log.d(TAG, "Sending message: $content")
                
                // Get active chain messages for history context
                val activeChainId = messageThread.activeChainId
                val conversationHistory = if (activeChainId != null) {
                    // Get messages from active chain sorted by timestamp
                    messageThread.getActiveChainMessages()
                } else {
                    // If no active chain, just use the current user message
                    listOf(userMessage)
                }
                
                Log.d(TAG, "Sending message with conversation history. Chain: $activeChainId, History size: ${conversationHistory.size}")
                
                // Send the message with history context
                val response = repository.sendMessage(
                    message = content,
                    conversationHistory = conversationHistory,
                    activeChainId = activeChainId
                )
                
                Log.d(TAG, "Received response: $response")
          
                // Create bot response message
                val botResponse = createBotResponseMessage(response, threadId)

                // Get current active thread
                val thread = messageThreads[threadId]
                if (thread != null) {
                    if (thread.activeChainId != null) {
                        // Add to active chain
                        val chainBotResponse = botResponse.copy(chainId = thread.activeChainId)
                        thread.addMessageToActiveChain(chainBotResponse)
                        
                        // Add bot response to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(chainBotResponse)
                        _messages.value = updatedMessages
                        
                    } else {
                        // Update the current version with the bot response
                        thread.updateCurrentVersion(botResponse = botResponse, updateChain = false)
                        
                        // Add bot response to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(botResponse)
                        _messages.value = updatedMessages
                    }
                    
                    // Log the updated chain structure for debugging
                    thread.logChainStructure()
                }
            } catch (e: Exception) {
                Log.d(TAG, "Error sending message", e)
                
                // Handle error
                val errorMessage = Message(
                    id = System.currentTimeMillis().toString(),
                    content = "Error: ${e.message}",
                    type = MessageType.ERROR,
                    timestamp = Date(),
                    threadId = threadId
                )

                val thread = messageThreads[threadId]
                if (thread != null) {
                    if (thread.activeChainId != null) {
                        // Add to active chain
                        val chainErrorMsg = errorMessage.copy(chainId = thread.activeChainId)
                        thread.addMessageToActiveChain(chainErrorMsg)

                        // Add error to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(chainErrorMsg)
                        _messages.value = updatedMessages
                    } else {
                        // Update the current version with the error response
                        thread.updateCurrentVersion(botResponse = errorMessage)

                        // Add error to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(errorMessage)
                        _messages.value = updatedMessages
                    }
                }
            }
        }
    }

    private fun createBotResponseMessage(responseText: String, threadId: String): Message {
        // Check for image url prefix
        if (responseText.contains("!IMAGEURL!")) {
            Log.d(TAG, "Found image URL prefix")
            val parts = responseText.split("!IMAGEURL!")
            val contentText = parts[0].trim()
            val imageUrl = parts[1].trim()

            return Message(
                id = System.currentTimeMillis().toString(),
                content = contentText,
                type = MessageType.BOT,
                timestamp = Date(),
                containsImage = true,
                imageUrl = imageUrl,
                threadId = threadId
            )
        }
        // Check for image data prefix
        else if (responseText.contains("!IMAGEDATA!")) {
            Log.d(TAG, "Found image data prefix")
            val parts = responseText.split("!IMAGEDATA!")
            val contentText = parts[0].trim()
            val imageData = parts[1].trim()

            return Message(
                id = System.currentTimeMillis().toString(),
                content = contentText,
                type = MessageType.BOT,
                timestamp = Date(),
                containsImage = true,
                imageData = imageData,
                threadId = threadId
            )
        }
        //Regular text response
        else {
            return Message(
                id = System.currentTimeMillis().toString(),
                content = responseText,
                type = MessageType.BOT,
                timestamp = Date(),
                threadId = threadId
            )
        }
    }

    fun logAllThreads() {
        messageThreads.forEach { (threadId, thread) ->
            Log.d(TAG, "Thread $threadId has ${thread.versions.size} versions")
            thread.logVersions(TAG)

            Log.d(TAG, "Thread $threadId has ${thread.chains.size} chains")
            thread.chains.forEach { (chainId, chain) ->
                Log.d(TAG, " Chain $chainId from version ${chain.fromVersionIndex} has ${chain.messages.size} messages")
            }
        }
    }

    fun editMessage(messageId: String, newContent: String) {
        Log.d(TAG, "Starting edit for message $messageId")
        val currentMessages = _messages.value?.toMutableList() ?: return

        // Find the message to edit
        val messageIndex = currentMessages.indexOfFirst { it.id == messageId }
        if (messageIndex == -1) {
            Log.e(TAG, "Could not find message with ID: $messageId")
            return
        }

        val messageToEdit = currentMessages[messageIndex]
        val threadId = messageToEdit.threadId ?: return

        // Determine the lineade ID (use existing one or create a new from original message Id)
        var editLineageId = messageToEdit.editLineageId

        Log.d(TAG, "Editing message in thread $threadId, lineage ID: $editLineageId")

        Log.d(TAG, "Editing message in thread $threadId")
        
        if (editLineageId == null) {

            val thread = messageThreads[threadId]

            if (thread != null) {
                for (chain in thread.chains.values) {
                    for (msg in chain.messages) {
                        if (msg.id == messageId || msg.originalMessageId == messageId) {
                            // Found a match - use its lineage if available, or its ID as lineage
                            editLineageId = msg.editLineageId ?: msg.id
                            break
                        }
                    }
                    if (editLineageId != null) break
                }
            }
            // If no lineage found, use messages own Id
            editLineageId = editLineageId ?: messageId
        }
        Log.d(TAG, "Editing message in thread $threadId, lineage ID: $editLineageId")

        // Track active thread for navigation
        activeThreadId = threadId

        // Get the thread or create one if it doesn't exist
        val thread = messageThreads[threadId] ?: run {
            Log.d(TAG, "Creating new thread for $threadId")
            val newThread = MessageThread(threadId)
            messageThreads[threadId] = newThread
            newThread
        }

        Log.d(TAG, "Current thread state before edit: " +
              "versions=${thread.versions.size}, " +
              "currentIndex=${thread.currentVersionIndex}")

        // Create a new message version
        val editedUserMessage = Message(
            id = System.currentTimeMillis().toString(),
            content = newContent,
            type = MessageType.USER,
            timestamp = Date(),
            threadId = threadId,
            hasVersionHistory = true,
            versionNumber = thread.versions.size,
            originalMessageId = messageId,
            editLineageId = editLineageId ?: messageId
        )

        // Add the new version to the thread
        val newVersionIndex = thread.addVersion(editedUserMessage)
        Log.d(TAG, "Added version at index $newVersionIndex. Total versions now: ${thread.versions.size}")

        markAllThreadVersionsWithHistory(threadId)

        // Create new chain for edited version
        val newChainId = thread.createNewChain()
        Log.d(TAG, "Created new chain $newChainId for edited message")

        // Find previous chain to copy messages from
        val previousChainId = thread.chains.keys
            .filter { it != newChainId }
            .maxByOrNull { thread.chains[it]?.timestamp ?: Date(0) }

        val messagesToInclude = mutableListOf<Message>()
        val previousChain = previousChainId?.let { thread.chains[it] }
 
        if (previousChain != null) {
            Log.d(TAG, "Previous chain found: $previousChainId with ${previousChain.messages.size} messages")
        
            // Find the index of the message being edited in the previous chain
            val originalMessageIndex = previousChain.messages.indexOfFirst { 
                it.id == messageId || (it.type == MessageType.USER && it.content == messageToEdit.content)
            }
        
            if (originalMessageIndex >= 0) {
            Log.d(TAG, "Found original message at position $originalMessageIndex in previous chain")
            
                // Clear the data structures we'll use to track messages
                val orderedMessages = mutableMapOf<Int, Message>()
                thread.chains[newChainId]?.messages?.clear()
            
                // Copy messages BEFORE the edited message with their original positions
                for (i in 0 until originalMessageIndex) {
                    val originalMsg = previousChain.messages[i]
                    val msg = originalMsg.copy(
                        chainId = newChainId,
                        editLineageId = originalMsg.editLineageId ?: originalMsg.id, // Keep lineage
                        originalMessageId = originalMsg.originalMessageId ?: originalMsg.id // Keep original message Id
                    )
                    orderedMessages[i] = msg
                    thread.addMessageToActiveChain(msg)
                    Log.d(TAG, "Added previous message to new chain: ${msg.content?.take(20)}")
                }
            
                // Add the edited message at the ORIGINAL position (replacing the old one)
                val chainMessage = editedUserMessage.copy(chainId = newChainId)
                orderedMessages[originalMessageIndex] = chainMessage
                thread.addMessageToActiveChain(chainMessage)
            
                // DO NOT add the edited message at the beginning also!
            
                // Add messages to the visible list in correct order
                messagesToInclude.addAll(orderedMessages.toSortedMap().values)
            } else {
                // If we can't find the original message, just add the edited message
                val chainMessage = editedUserMessage.copy(chainId = newChainId)
                messagesToInclude.add(chainMessage)
                thread.addMessageToActiveChain(chainMessage)
                Log.d(TAG, "Could not find original message in previous chain, adding only edited message")
            }
        } else {
            // No previous chain, just add the edited message
            Log.d(TAG, "No previous chain found")
            val chainMessage = editedUserMessage.copy(chainId = newChainId)
            messagesToInclude.add(chainMessage)
            thread.addMessageToActiveChain(chainMessage)
        }
    
        Log.d(TAG, "== EDIT LINEAGE SUMMARY ==")
        thread.chains.forEach { (chainId, chain) ->
            chain.messages.forEach { msg ->
                if (msg.type == MessageType.USER && (msg.editLineageId != null || msg.originalMessageId != null)) {
                    Log.d(TAG, "Chain ${chainId.take(8)}: Message ${msg.id.take(8)}, content=${msg.content?.take(20)}, " +
                            "originalId=${msg.originalMessageId?.take(8) ?: "none"}, " +
                            "lineageId=${msg.editLineageId?.take(8) ?: "none"}")
                }
            }
        }              
        // Update the UI with preserved messages plus edited message
        _messages.value = messagesToInclude

        // Fetch a new response for the edited message
        viewModelScope.launch {
            try {
                Log.d(TAG, "Sending edited message: $newContent")
                
                // Get the conversation history for this new chain
                val conversationHistory = thread.getActiveChainMessages()
                
                // Send message with conversation history context
                val response = repository.sendMessage(
                    message = newContent,
                    conversationHistory = conversationHistory,
                    activeChainId = newChainId
                )
                
                Log.d(TAG, "Received response for edited message: $response")

                // Create the new bot response
                val newBotResponse = createBotResponseMessage(response, threadId).copy(
                    versionNumber = newVersionIndex,
                    hasVersionHistory = true,
                    chainId = newChainId
                )

                // Update the thread with the new bot response
                thread.updateCurrentVersion(botResponse = newBotResponse, updateChain = false)
                thread.addMessageToActiveChain(newBotResponse)

                // Add the new bot response to visible messages
                val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                updatedMessages.add(newBotResponse)
                _messages.value = updatedMessages
                MessageTableLogger.logMessageChainsAsTable(thread)
                
                // Log the updated chain structure
                thread.logChainStructure()

            } catch (e: Exception) {
                Log.e(TAG, "Error sending edited message", e)

                // Handle error
                val errorMessage = Message(
                    id = System.currentTimeMillis().toString(),
                    content = "Error: ${e.message}",
                    type = MessageType.ERROR,
                    timestamp = Date(),
                    threadId = threadId,
                    versionNumber = newVersionIndex,
                    hasVersionHistory = true,
                    chainId = newChainId
                )

                // Update the thread with the error response
                thread.updateCurrentVersion(botResponse = errorMessage, updateChain = false)
                thread.addMessageToActiveChain(errorMessage)

                // Add error to visible messages
                val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                updatedMessages.add(errorMessage)
                _messages.value = updatedMessages
                MessageTableLogger.logMessageChainsAsTable(thread)
            }
        }
    }

    /**
     * Navigate to specific version of a message thread
     */
    fun navigateToSpecificVersion(threadId: String, targetVersionIndex: Int): Boolean {
        Log.d(TAG, "Attempting to navigate to specific version $targetVersionIndex in thread $threadId")
        val thread = messageThreads[threadId] ?: return false

        // Validate target index
        if (targetVersionIndex < 0 || targetVersionIndex >= thread.versions.size) {
            return false
        }

        // Set the current version index directly
        thread.currentVersionIndex = targetVersionIndex

        // Find or create a chain for this version
        val chainsForVersion = thread.getChainsForVersion(targetVersionIndex)
        val chainId = if (chainsForVersion.isNotEmpty()) {
            chainsForVersion.maxByOrNull { it.timestamp }?.chainId
        } else {
            thread.createNewChain()
        }

        // Switch to this chain
        if (chainId != null) {
            // Get messages from this chain
            val chainMessages = thread.chains[chainId]?.messages ?: emptyList()
            // Replace current messages from the messages in this chain
            _messages.value = ArrayList(chainMessages)

            MessageTableLogger.logMessageChainsAsTable(thread)

            // Log the chain structure after navigation
            thread.logChainStructure()
            return true
        }
        return false
    }
    /**
     * Navigate to the previous version of a message thread
     */
    fun navigateToPreviousVersion(threadId: String): Boolean {
        Log.d(TAG, "Attempting to navigate to previous version in thread $threadId")
        val thread = messageThreads[threadId] ?: run {
            Log.d(TAG, "Thread not found")
            return false
        }

        if (!thread.hasPreviousVersion()) {
            Log.d(TAG, "No previous version available")
            return false
        }

        val previousVersion = thread.moveToPreviousVersion() ?: return false

        // Get the chain related to this thread
        val chainId = thread.activeChainId ?: return false

        return handleChainNavigation(chainId)
    }

    /**
     * Navigate to the next version of a message thread
     */
    fun navigateToNextVersion(threadId: String): Boolean {
        Log.d(TAG, "Attempting to navigate to next version in thread $threadId")
        val thread = messageThreads[threadId] ?: run {
            Log.d(TAG, "No next thread found")
            return false
        }

        if (!thread.hasNextVersion()) {
            Log.d(TAG, "No next version available")
            return false
        }
 
        val nextVersion = thread.moveToNextVersion() ?: return false
        // Get the chain related to this version
        val chainId = thread.activeChainId ?: return false

        return handleChainNavigation(chainId)

    }

    private fun markAllThreadVersionsWithHistory(threadId: String) {
        val thread = messageThreads[threadId] ?: return
    
        // Only mark with history if there's more than one version
        if (thread.versions.size <= 1) return
    
        Log.d(TAG, "Marking all ${thread.versions.size} versions in thread $threadId with hasVersionHistory")
    
        // Update all versions with hasVersionHistory flag
        for (i in thread.versions.indices) {
            val version = thread.versions[i]
        
            // Update user message
            val updatedUserMessage = version.userMessage.copy(hasVersionHistory = true)
        
            // Update bot response if it exists
            val updatedBotResponse = version.botResponse?.copy(hasVersionHistory = true)
        
            // Replace the version
            thread.versions[i] = MessageVersion(updatedUserMessage, updatedBotResponse, version.timestamp)
        }
    }

    private fun validateChain(chainId: String) {
        val threadId = activeThreadId ?: return
        val thread = messageThreads[threadId] ?: return
        val chain = thread.chains[chainId] ?: return

        // Remove duplicate bot responses
        val uniqueMessages = mutableListOf<Message>()
        val seenBotResponses = mutableSetOf<String>()
        
        chain.messages.forEach { message ->
            if (message.type == MessageType.BOT) {
                val content = message.content ?: ""
                if (!seenBotResponses.contains(content)) {
                    seenBotResponses.add(content)
                    uniqueMessages.add(message)
                } else {
                    Log.d(TAG, "Removed duplicate bot response: ${content.take(20)}...")
                }
            } else {
                uniqueMessages.add(message)
            }
        }
        // Only replace if we removed messages
        if (uniqueMessages.size < chain.messages.size) {
            Log.d(TAG, "Chain validation removed ${chain.messages.size - uniqueMessages.size} duplicate messages")
            chain.messages.clear()
            chain.messages.addAll(uniqueMessages)
        }
    }

    /**
     * Ensures chain navigation updates UI correctly
     */
    private fun handleChainNavigation(chainId: String): Boolean {
        val threadId = activeThreadId ?: return false
        val thread = messageThreads[threadId] ?: return false
        val chain = thread.chains[chainId] ?: return false
    
        // Set the active chain
        thread.activeChainId = chainId
    
        // Get messages from this chain
        val chainMessages = chain.messages.toList()
    
        // Important: Create a new list to break reference to old list state
        _messages.value = ArrayList(chainMessages)
    
        // Log the chain switch
        Log.d(TAG, "Switched to chain $chainId with ${chainMessages.size} messages")
    
        // Log chain structure after navigation
        thread.logChainStructure()
        return true
    }

    /**
     * Updates visible messages to display the specified version's chain
     */
    fun switchToChain(threadId: String, chainId: String): Boolean { 
        val thread = messageThreads[threadId] ?: return false

        // Activate the requested chain
        val chainMessages = thread.activateChain(chainId) ?: return false

        // Update the UI with the messages from this chain
        _messages.value = chainMessages

        // Log chain structure after navigation
        thread.logChainStructure()

        return true
    }

    fun getMessageThread(threadId: String): MessageThread? {
        return messageThreads[threadId]
    }

    fun getMessageThreads(): Map<String, MessageThread> {
        return messageThreads
    }
}