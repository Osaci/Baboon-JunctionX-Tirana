package com.example.lilotest.ui.chat

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Color
import android.graphics.Typeface
import android.text.SpannableString
import android.text.Spanned
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.util.Base64
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.HorizontalScrollView
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import io.noties.markwon.Markwon
import io.noties.markwon.ext.tables.TablePlugin
import android.text.SpannableStringBuilder
import android.text.method.LinkMovementMethod
import android.text.method.MovementMethod
import android.widget.TableLayout
import android.widget.TableRow

import java.util.regex.Pattern

fun Markwon.toMarkdownCharSequence(markdown: String): CharSequence {
    val builder = SpannableStringBuilder()
    this.setMarkdown(builder, markdown)
    return builder
}

class MessageAdapter : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {
    private val TAG = "MessageAdapter"


    // Example implementation of a TableAwareMovementMethod for handling links in tables
    class TableAwareMovementMethod private constructor(private val delegate: MovementMethod) :
        MovementMethod by delegate {
        companion object {
            fun create(): MovementMethod {
                return TableAwareMovementMethod(LinkMovementMethod.getInstance())
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {
        val layoutId = when (viewType) {
            VIEW_TYPE_USER -> R.layout.item_message_user
            VIEW_TYPE_BOT_WITH_IMAGE -> R.layout.item_message_bot_with_image
            VIEW_TYPE_BOT -> R.layout.item_message_bot
            else -> R.layout.item_message_error
        }

        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false)
        return MessageViewHolder(view)
    }




    private fun processMessageWithSpecialBlocks(
        messageText: String,
        holder: MessageViewHolder,
        message: Message
    ) {
        try {
            // Hide the regular Content TextView since we'll be using the container
            holder.getContentTextView()?.visibility = View.GONE

            // Get the content container
            val contentContainer = holder.getContentContainer()
            if (contentContainer == null) {
                Log.e(TAG, "Content container not found in layout")
                // Fallback to regular TextView if container not found
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = messageText
                }
                holder.setTimestamp(message.timestamp)
                return
            }

            // Make container visible
            contentContainer.visibility = View.VISIBLE

            // Clear content container
            contentContainer.removeAllViews()

            // Find all code blocks
            val codeBlocks = findCodeBlocks(messageText)
            Log.d(TAG, "Found ${codeBlocks.size} code blocks in message")

            // Find all table blocks
            val tableBlocks = findTableBlocks(messageText)
            Log.d(TAG, "Found ${tableBlocks.size} table blocks in message")

            // Combine both types of blocks and sort by position
            val allBlocks = (codeBlocks + tableBlocks).sortedBy { it.startPosition }

            if (allBlocks.isEmpty()) {
                // If no special blocks are found, format text normally
                val formattedText =
                    formatTextWithoutCodeBlocks(messageText, holder.itemView.context)
                val textView = createTextView(holder.itemView.context, formattedText)
                contentContainer.addView(textView)
            } else {
                var lastPosition = 0

                for (block in allBlocks) {
                    // Add text before the block
                    if (block.startPosition > lastPosition) {
                        val textBefore = messageText.substring(lastPosition, block.startPosition)
                        if (textBefore.isNotEmpty()) {
                            val formattedText =
                                formatTextWithoutCodeBlocks(textBefore, holder.itemView.context)
                            val textView = createTextView(holder.itemView.context, formattedText)
                            contentContainer.addView(textView)
                        }
                    }

                    // Add the block based on its type
                    if (block.language == "table") {
                        // This is a table block
                        val tableView = processMarkdownTable(block.code, holder.itemView.context)
                        contentContainer.addView(tableView)
                    } else {
                        // This is a code block
                        val codeBlockView = createCodeBlockView(
                            holder.itemView.context,
                            block.language,
                            block.code
                        )
                        contentContainer.addView(codeBlockView)
                    }

                    // Update last position
                    lastPosition = block.endPosition
                }

                // Add remaining text after the last block
                if (lastPosition < messageText.length) {
                    val textAfter = messageText.substring(lastPosition)
                    if (textAfter.isNotEmpty()) {
                        val formattedText =
                            formatTextWithoutCodeBlocks(textAfter, holder.itemView.context)
                        val textView = createTextView(holder.itemView.context, formattedText)
                        contentContainer.addView(textView)
                    }
                }
            }

            // Set the timestamp
            holder.setTimestamp(message.timestamp)

            // Hide the old code blocks container
            holder.getCodeBlocksContainer()?.visibility = View.GONE

        } catch (e: Exception) {
            Log.e(TAG, "Error processing message with special blocks: ${e.message}")
            e.printStackTrace()

            // Fallback to simple TextView
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = messageText
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    // Create text view for text content
    private fun createTextView(context: Context, text: SpannableString): TextView {
        val textView = TextView(context)
        textView.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        textView.textSize = 16f
        textView.text = text
        return textView
    }


    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)

        try {
            // Get the message content safely
            val content = message.content ?: ""

            Log.d(TAG, "Processing message ID ${message.id}, content length: ${content.length}")

            // Check for code blocks or tables
            val hasSpecialBlocks = content.contains("```") || containsMarkdownTable(content)

            if (hasSpecialBlocks) {
                // Process content with special blocks
                processMessageWithSpecialBlocks(content, holder, message)
            } else {
                // Use text response for other parts
                val formattedText = formatTextWithoutCodeBlocks(content, holder.itemView.context)

                // Make sure regular text view has content
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = formattedText
                }

                // Set timestamp
                holder.setTimestamp(message.timestamp)
            }

            // Process images (unchanged)
            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar =
                    holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE

                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Loading from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(
                                RequestOptions()
                                    .diskCacheStrategy(DiskCacheStrategy.ALL)
                                    .error(R.drawable.ic_error_placeholder)
                            )
                            .into(imageView)
                            .clearOnDetach()

                        progressBar.visibility = View.GONE

                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base 64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image data
                                val base64Data =
                                    message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(
                                        RequestOptions()
                                            .diskCacheStrategy(DiskCacheStrategy.NONE)
                                            .error(R.drawable.ic_error_placeholder)
                                    )
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try decoding directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(
                                        RequestOptions()
                                            .diskCacheStrategy(DiskCacheStrategy.NONE)
                                            .error(R.drawable.ic_error_placeholder)
                                    )
                                    .into(imageView)
                                    .clearOnDetach()
                            }
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()

            // Fallback to text binding
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = message.content ?: ""
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = getItem(position)
        return when {
            message.type == MessageType.USER -> VIEW_TYPE_USER
            message.type == MessageType.BOT && message.containsImage -> VIEW_TYPE_BOT_WITH_IMAGE
            message.type == MessageType.BOT -> VIEW_TYPE_BOT
            else -> VIEW_TYPE_ERROR
        }
    }

    // Checks if the message contains a markdown table
    private fun containsMarkdownTable(text: String): Boolean {
        val pattern = Pattern.compile("\\|(.+?)\\|[\\s\\S]*?\\|", Pattern.DOTALL)
        val matcher = pattern.matcher(text)
        return matcher.find()
    }


    private data class CodeBlock(
        val language: String,
        val code: String,
        val startPosition: Int,
        val endPosition: Int
    )


    private class MarkdownTableRenderer(
        private val context: Context,
        private val tableText: String
    ) {
        // Table border color
        private val borderColor = ContextCompat.getColor(context, R.color.table3)

        // Background colors
        private val headerBgColor = ContextCompat.getColor(context, R.color.table3)
        private val evenRowBgColor = ContextCompat.getColor(context, R.color.table1)
        private val oddRowBgColor = ContextCompat.getColor(context, R.color.white)

        // Parse and render the table
        fun renderToTableLayout(tableLayout: TableLayout) {
            try {
                // Parse the markdown table
                val tableData = parseMarkdownTable(tableText)

                if (tableData.isEmpty()) {
                    Log.e("MarkdownTableRenderer", "Failed to parse table data")
                    return
                }

                // Clear any existing views
                tableLayout.removeAllViews()

                // Set table properties
                tableLayout.setBackgroundColor(borderColor)
                tableLayout.setPadding(1, 1, 1, 1) // Border width

                // Add rows to the table
                for (rowIndex in tableData.indices) {
                    val rowData = tableData[rowIndex]

                    // Create table row
                    val tableRow = TableRow(context)
                    tableRow.layoutParams = TableLayout.LayoutParams(
                        TableLayout.LayoutParams.MATCH_PARENT,
                        TableLayout.LayoutParams.WRAP_CONTENT
                    )

                    // Set row background color
                    val bgColor = when {
                        rowIndex == 0 -> headerBgColor // Header row
                        rowIndex % 2 == 0 -> evenRowBgColor // Even row
                        else -> oddRowBgColor // Odd row
                    }
                    tableRow.setBackgroundColor(bgColor)

                    // Add cells to the row
                    for (cellData in rowData) {
                        val cell = createTableCell(cellData, rowIndex == 0)
                        tableRow.addView(cell)
                    }

                    // Add row to table
                    tableLayout.addView(tableRow)
                }
            } catch (e: Exception) {
                Log.e("MarkdownTableRenderer", "Error rendering table: ${e.message}")
                e.printStackTrace()
            }
        }

        // Create a table cell view
        private fun createTableCell(cellText: String, isHeader: Boolean): TextView {
            val cell = TextView(context)

            // Set cell properties
            cell.layoutParams = TableRow.LayoutParams(
                TableRow.LayoutParams.WRAP_CONTENT,
                TableRow.LayoutParams.WRAP_CONTENT
            ).apply {
                setMargins(1, 1, 1, 1) // Cell spacing
            }

            // Apply styling
            cell.setPadding(16, 12, 16, 12)
            cell.setBackgroundColor(if (isHeader) headerBgColor else oddRowBgColor)

            if (isHeader) {
                cell.setTypeface(null, Typeface.BOLD)
            }

            // Handle markdown formatting in cell text
            try {
                // Create a Markwon instance for inline formatting
                val markwon = Markwon.builder(context).build()
        
                // Clean up the text (remove extra spaces, etc.)
                val cleanText = cellText.trim()
        
                // For simple bold text, handle it directly without markwon
                if (cleanText.contains("**")) {
                    val noAsterisks = cleanText.replace("**", "")
                    cell.text = noAsterisks
                    cell.setTypeface(null, Typeface.BOLD)
                } else {
                    // For regular text, just set it directly
                    cell.text = cleanText
                }
            } catch (e: Exception) {
                // Fallback to plain text
                cell.text = cellText
            }
    
            return cell
        }

        private fun formatCellText(text: String): String {
            // Create a simple string without markdown formatting
            try {
                // Remove Markdown formatting characters but keep the content
                var result = text.trim()
        
                // Handle bold formatting
                result = result.replace("\\*\\*(.*?)\\*\\*".toRegex()) { it.groupValues[1] }
        
                // Handle italic formatting
                result = result.replace("\\*(.*?)\\*".toRegex()) { it.groupValues[1] }
        
                // Handle inline code
                result = result.replace("`(.*?)`".toRegex()) { it.groupValues[1] }
        
                return result
            } catch (e: Exception) {
                return text // Fallback to original text
            }
        }
    }

    private fun findTableBlocks(text: String): List<CodeBlock> {
        val tableBlocks = mutableListOf<CodeBlock>()

        try {
            // Pattern to detect markdown tables - look for lines with pipe characters
            // This matches any line starting with a pipe, followed by content, and ending with a pipe
            val tablePattern = Pattern.compile(
                "(\\|[^\\n]*\\|[\\s]*\\n){2,}", // Match 2+ consecutive lines with pipes
                Pattern.DOTALL
            )
            val matcher = tablePattern.matcher(text)

            // Find all table matches
            while (matcher.find()) {
                val tableText = matcher.group(0) ?: ""
                if (tableText.isNotEmpty() && !isPositionInsideCodeBlock(text, matcher.start())) {
                    // Add the table as a code block
                    tableBlocks.add(
                        CodeBlock(
                            language = "table",
                            code = tableText.trim(),
                            startPosition = matcher.start(),
                            endPosition = matcher.end()
                        )
                    )

                    Log.d(TAG, "Found table at positions ${matcher.start()}-${matcher.end()}")
                }
            }

            // Also look for indented tables (like in the example)
            if (tableBlocks.isEmpty()) {
                val indentedPattern = Pattern.compile(
                    "(\\s+\\|[^\\n]*\\|[\\s]*\\n){2,}",
                    Pattern.DOTALL
                )
                val indentedMatcher = indentedPattern.matcher(text)

                while (indentedMatcher.find()) {
                    val tableText = indentedMatcher.group(0) ?: ""
                    if (tableText.isNotEmpty() && !isPositionInsideCodeBlock(
                            text,
                            indentedMatcher.start()
                        )
                    ) {
                        // Clean indentation
                        val cleanedTable = tableText.split("\n").joinToString("\n") { line ->
                            line.trimStart()
                        }

                        tableBlocks.add(
                            CodeBlock(
                                language = "table",
                                code = cleanedTable.trim(),
                                startPosition = indentedMatcher.start(),
                                endPosition = indentedMatcher.end()
                            )
                        )

                        Log.d(
                            TAG,
                            "Found indented table at positions ${indentedMatcher.start()}-${indentedMatcher.end()}"
                        )
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding table blocks: ${e.message}")
            e.printStackTrace()
        }

        return tableBlocks
    }

    // Update the processMarkdownTable function to use the custom renderer
    private fun processMarkdownTable(tableText: String, context: Context): View {
        try {
            Log.d(TAG, "Processing markdown table: ${tableText.take(50)}...")

            // Inflate the table layout
            val tableLayout = LayoutInflater.from(context)
                .inflate(R.layout.item_table_layout, null, false)

            // Set layout parameters
            tableLayout.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            // Get views
            val copyButton = tableLayout.findViewById<Button>(R.id.copy_table_button)
            val tableContainer = tableLayout.findViewById<TableLayout>(R.id.table_content_container)

            // Set up copy button
            copyButton?.setOnClickListener {
                val clipboard =
                    context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Table Content", tableText)
                clipboard.setPrimaryClip(clip)
                Toast.makeText(context, "Table copied to clipboard", Toast.LENGTH_SHORT).show()
            }

            // Add drawable to copy button if available
            try {
                val drawableId = R.drawable.ic_copy
                copyButton?.setCompoundDrawablesWithIntrinsicBounds(drawableId, 0, 0, 0)
            } catch (e: Exception) {
                Log.e(TAG, "Error setting copy icon: ${e.message}")
            }

            // Process the table text to ensure proper formatting
            val processedTableText = ensureProperTableFormat(tableText)

            // Use the custom table renderer
            val tableRenderer = MarkdownTableRenderer(context, processedTableText)
            tableRenderer.renderToTableLayout(tableContainer)

            return tableLayout
        } catch (e: Exception) {
            Log.e(TAG, "Error processing markdown table: ${e.message}")
            e.printStackTrace()

            // Fallback to simple TextView
            val textView = TextView(context)
            textView.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
            textView.text = tableText
            return textView
        }
    }

    // You may also want to improve the table format method
    private fun ensureProperTableFormat(tableText: String): String {
        try {
            // Split text into lines and clean up
            val lines = tableText.trim().split("\n").map { it.trim() }

            // We need at least one line for a header
            if (lines.isEmpty()) {
                return "| Column |\n|--------|"
            }

            val formattedLines = mutableListOf<String>()

            // Process each line to ensure it starts and ends with pipe
            for (line in lines) {
                if (line.isBlank()) continue

                var formattedLine = line
                if (!formattedLine.startsWith("|")) {
                    formattedLine = "| $formattedLine"
                }
                if (!formattedLine.endsWith("|")) {
                    formattedLine = "$formattedLine |"
                }
                formattedLines.add(formattedLine)
            }

            // If we don't have at least 2 lines (header + separator), add a separator
            if (formattedLines.size < 2 || !formattedLines[1].contains("-")) {
                // Count columns in the header
                val columnCount = formattedLines[0].count { it == '|' } - 1

                // Build a proper separator row
                val separatorBuilder = StringBuilder("|")
                for (i in 0 until columnCount) {
                    separatorBuilder.append("---|")
                }

                // Insert the separator after the header
                formattedLines.add(1, separatorBuilder.toString())
            }

            // Ensure we have at least 3 rows (header, separator, data)
            if (formattedLines.size < 3) {
                formattedLines.add("| Data |")
            }

            // Join lines and return formatted table
            return formattedLines.joinToString("\n")
        } catch (e: Exception) {
            Log.e(TAG, "Error formatting table: ${e.message}")
            return tableText // Return original if processing fails
        }
    }


    // Helper method to check if a position in text is inside a code block
    private fun isPositionInsideCodeBlock(text: String, position: Int): Boolean {
        val codeBlockPattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
        val matcher = codeBlockPattern.matcher(text)

        while (matcher.find()) {
            if (position >= matcher.start() && position <= matcher.end()) {
                return true
            }
        }

        return false
    }

    // Find all code blocks
    private fun findCodeBlocks(text: String): List<CodeBlock> {
        val codeBlocks = mutableListOf<CodeBlock>()

        // Finding match for code blocks with language identifier
        try {
            val pattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
            val matcher = pattern.matcher(text)

            while (matcher.find()) {
                val language = matcher.group(1) ?: ""
                var codeContent = matcher.group(2) ?: ""

                // Handle escaped newlines in the code content
                if (codeContent.contains("\\n")) {
                    codeContent = codeContent.replace("\\n", "\n")
                }

                Log.d(
                    TAG,
                    "Found code block: language=$language, position=${matcher.start()}-${matcher.end()}"
                )

                codeBlocks.add(
                    CodeBlock(
                        language = language,
                        code = codeContent.trim(),
                        startPosition = matcher.start(),
                        endPosition = matcher.end()
                    )
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding code blocks: ${e.message}.")
            e.printStackTrace()
        }
        return codeBlocks
    }


    // Format text without code blocks (formatting bold and inline code)
    private fun formatTextWithoutCodeBlocks(text: String, context: Context): SpannableString {
        try {
            // Process bold text
            val boldPattern = Pattern.compile("\\*\\*(.*?)\\*\\*")
            val boldMatcher = boldPattern.matcher(text)

            // Find bold matches and collect them
            val boldMatches = mutableListOf<Triple<Int, Int, String>>()
            while (boldMatcher.find()) {
                boldMatches.add(
                    Triple(
                        boldMatcher.start(),
                        boldMatcher.end(),
                        boldMatcher.group(1) ?: ""
                    )
                )
            }

            // Create a new string with bold markers removed
            val resultText = StringBuilder(text)
            var offset = 0
            for ((start, end, innerText) in boldMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = end - offset
                resultText.replace(adjustedStart, adjustedEnd, innerText)
                offset += 4 // Remove asterisks
            }

            // Create spannable with modified text
            val result = SpannableString(resultText.toString())

            // Apply bold formatting
            offset = 0
            for ((start, end, innerText) in boldMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = adjustedStart + innerText.length

                result.setSpan(
                    StyleSpan(Typeface.BOLD),
                    adjustedStart,
                    adjustedEnd,
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                offset += 4
            }

            // Process inlineCode
            val inlineCodePattern = Pattern.compile("`([^`]+?)`")
            val inlineCodeMatcher = inlineCodePattern.matcher(result.toString())

            // Get colors from resources
            val bgColor = ContextCompat.getColor(context, R.color.inline_code_bg)
                ?: Color.parseColor("#f5f5f5")
            val fgColor = ContextCompat.getColor(context, R.color.inline_code_fg)
                ?: Color.parseColor("#e83e8c")

            // Find all inline code matches and collect them
            val codeMatches = mutableListOf<Triple<Int, Int, String>>()
            while (inlineCodeMatcher.find()) {
                var innerText = inlineCodeMatcher.group(1) ?: continue

                // Handle newlines
                if (innerText.contains("\\n")) {
                    innerText = innerText.replace("\\n", "\n")
                }

                codeMatches.add(
                    Triple(
                        inlineCodeMatcher.start(),
                        inlineCodeMatcher.end(),
                        innerText
                    )
                )
            }

            // If no inline code return result with bold formatting
            if (codeMatches.isEmpty()) {
                return result
            }

            // Create a new string with inline backticks removed
            val finalText = StringBuilder(result.toString())
            offset = 0

            for ((start, end, innerText) in codeMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = end - offset
                finalText.replace(adjustedStart, adjustedEnd, innerText)
                offset += 2  // remove backticks
            }

            // Create final spannable with all formatting
            val finalResult = SpannableString(finalText.toString())

            // Copy existing bold spans
            val spans = result.getSpans(0, result.length, StyleSpan::class.java)
            for (span in spans) {
                val spanStart = result.getSpanStart(span)
                val spanEnd = result.getSpanEnd(span)
                val spanFlags = result.getSpanFlags(span)

                // Adjust position for any spans that might be affected by inline code removal
                var adjustedStart = spanStart
                var adjustedEnd = spanEnd

                // if spans starts after inline codeblock
                for ((start, end, innerText) in codeMatches) {
                    if (spanStart > end) {
                        adjustedStart -= 2 // Two removed backticks
                    }
                    // if spans starts before inline codeblock
                    if (spanEnd > end) {
                        adjustedEnd -= 2
                    }
                }

                if (adjustedStart < adjustedEnd && adjustedEnd <= finalResult.length) {
                    finalResult.setSpan(span, adjustedStart, adjustedEnd, spanFlags)
                }
            }
            // Apply inline code formatting
            offset = 0
            for ((start, end, innerText) in codeMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = adjustedStart + innerText.length

                if (adjustedStart < adjustedEnd && adjustedEnd <= finalResult.length) {
                    // Apply background color
                    finalResult.setSpan(
                        BackgroundColorSpan(bgColor),
                        adjustedStart,
                        adjustedEnd,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )

                    // Apply text color
                    finalResult.setSpan(
                        ForegroundColorSpan(fgColor),
                        adjustedStart,
                        adjustedEnd,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )

                    // Apply monospace font
                    finalResult.setSpan(
                        TypefaceSpan("monospace"),
                        adjustedStart,
                        adjustedEnd,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
                offset += 2
            }
            return finalResult

        } catch (e: Exception) {
            Log.e(TAG, "Error formatting text: ${e.message}")
            e.printStackTrace()
            return SpannableString(text)
        }
    }

    // Create code block with syntax highlighter
    private fun createCodeBlockView(
        context: Context,
        language: String,
        code: String
    ): View {
        try {
            //Inflate code block layout
            val codeBlockView = LayoutInflater.from(context)
                .inflate(R.layout.item_code_block, null, false)

            // Set layout parameters
            codeBlockView.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            // Get views
            val languageLabel = codeBlockView.findViewById<TextView>(R.id.code_language_label)
            val copyButton = codeBlockView.findViewById<Button>(R.id.copy_code_button)
            val codeView = codeBlockView.findViewById<CodeView>(R.id.code_view)

            if (languageLabel == null || copyButton == null || codeView == null) {
                Log.e(TAG, "Missing views in code block layout")
                return TextView(context).apply {
                    text = code
                    typeface = Typeface.MONOSPACE
                }
            }
            // Set language label
            val displayLanguage = if (language.isNotEmpty()) language else "plaintext"
            languageLabel.text = displayLanguage

            // Set up copy button
            copyButton.setOnClickListener {
                val clipboard =
                    context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Code Snippet", code)
                clipboard.setPrimaryClip(clip)
                Toast.makeText(context, "Code copied to clipboard", Toast.LENGTH_SHORT).show()
            }

            // Add drawable to copy button if available
            try {
                val drawableId = R.drawable.ic_copy
                copyButton.setCompoundDrawablesWithIntrinsicBounds(drawableId, 0, 0, 0)
            } catch (e: Exception) {
                Log.e(TAG, "Error setting copy icon: ${e.message}")
            }

            // Configure code view with syntax highlighting
            try {
                val actualLanguage = if (language.isEmpty()) "text" else language
                codeView.setOptions(
                    Options.Default.get(context)
                        .withLanguage(actualLanguage)
                        .withTheme(ColorTheme.DEFAULT)
                        .withCode(code)
                )
            } catch (e: Exception) {
                Log.e(TAG, "Error setting code options: ${e.message}")
                codeView.setCode(code)
            }
            return codeBlockView
        } catch (e: Exception) {
            Log.e(TAG, "Error creating code block view: ${e.message}")
            e.printStackTrace()

            // Fallback: Return a simple TextView with the code
            return TextView(context).apply {
                text = code
                typeface = Typeface.MONOSPACE
                setPadding(16, 16, 16, 16)
                setBackgroundColor(Color.parseColor("#f5f5f5"))
            }
        }
    }

    private class MessageDiffCallback : DiffUtil.ItemCallback<Message>() {
        override fun areItemsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem == newItem
        }
    }

    companion object {
        private const val VIEW_TYPE_USER = 0
        private const val VIEW_TYPE_BOT = 1
        private const val VIEW_TYPE_ERROR = 2
        private const val VIEW_TYPE_BOT_WITH_IMAGE = 3
    }
}
