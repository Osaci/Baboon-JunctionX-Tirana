package com.example.lilotest.ui.chat

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Color
import android.graphics.Typeface
import android.text.SpannableString
import android.text.Spanned
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.util.Base64
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import java.util.regex.Pattern

class MessageAdapter : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {
    private val TAG = "MessageAdapter"

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {
        val layoutId = when (viewType) {
            VIEW_TYPE_USER -> R.layout.item_message_user
            VIEW_TYPE_BOT_WITH_IMAGE -> R.layout.item_message_bot_with_image
            VIEW_TYPE_BOT -> R.layout.item_message_bot
            else -> R.layout.item_message_error
        }

        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false) 
        return MessageViewHolder(view)
    }

    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)
        
        try {
            // Get the message content safely
            val content = message.content ?: ""
            
            // Process text with formatting
            val formattedText = formatText(content, holder.itemView.context)
            holder.bind(message, formattedText)
    
            // Process code blocks
            processCodeBlocks(content, holder.itemView)
    
            // If image in text load the image
            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)
    
                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE
    
                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Load from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(RequestOptions()
                                .diskCacheStrategy(DiskCacheStrategy.ALL)
                                .error(R.drawable.ic_error_placeholder))
                            .into(imageView)
                            .clearOnDetach()
    
                        progressBar.visibility = View.GONE
                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image URL
                                val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)
    
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try to decode directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
    
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            }
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = getItem(position)
        return when {
            message.type == MessageType.USER -> VIEW_TYPE_USER
            message.type == MessageType.BOT && message.containsImage -> VIEW_TYPE_BOT_WITH_IMAGE
            message.type == MessageType.BOT -> VIEW_TYPE_BOT
            else -> VIEW_TYPE_ERROR
        }
    }

    // Format text with bold, inline code
    private fun formatText(text: String, context: Context): SpannableString {
        try {
            // Make a copy of the text to work with
            val resultText = StringBuilder(text)
            val ranges = mutableListOf<FormattingRange>()
            
            // First, find and remove code blocks from main text
            // This must happen first to avoid invalid spans from stripped content
            removeCodeBlocks(text, resultText, ranges)
            
            // Then, find and process bold text
            processBoldText(resultText.toString(), resultText, ranges)
            
            // Finally, process inline code
            processInlineCode(resultText.toString(), resultText, ranges, context)
            
            // Create SpannableString from the modified text
            val spannableString = SpannableString(resultText.toString())
            
            // Apply spans
            applySpans(spannableString, ranges)
            
            return spannableString
        } catch (e: Exception) {
            Log.e(TAG, "Error formatting text: ${e.message}")
            e.printStackTrace()
            // Return the original text without formatting if there's an error
            return SpannableString(text)
        }
    }
    
    private data class FormattingRange(
        val start: Int, 
        val end: Int, 
        val type: FormattingType,
        val bgColor: Int = 0,
        val fgColor: Int = 0
    )
    
    private enum class FormattingType {
        BOLD, INLINE_CODE, CODE_BLOCK_REMOVED
    }
    
    // Process bold text (**text**)
    private fun processBoldText(
        originalText: String, 
        resultText: StringBuilder, 
        ranges: MutableList<FormattingRange>
    ) {
        try {
            val pattern = Pattern.compile("\\*\\*(.*?)\\*\\*")
            val matcher = pattern.matcher(originalText)
            
            var offset = 0
            while (matcher.find()) {
                val originalStart = matcher.start()
                val originalEnd = matcher.end()
                val innerText = matcher.group(1) ?: continue
                
                Log.d(TAG, "Bold match: '$innerText'")
                
                // Calculate positions in the modified text
                val adjustedStart = originalStart - offset
                val adjustedEnd = originalEnd - offset
                
                // Make sure the span will be valid
                if (adjustedStart < 0 || adjustedEnd > resultText.length || adjustedStart > adjustedEnd) {
                    Log.e(TAG, "Invalid bold range: $adjustedStart to $adjustedEnd in text length ${resultText.length}")
                    continue
                }
                
                ranges.add(FormattingRange(
                    adjustedStart, 
                    adjustedStart + innerText.length, 
                    FormattingType.BOLD
                ))
                
                resultText.replace(adjustedStart, adjustedEnd, innerText)
                offset += 4 // Length of two asterisks pairs
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error processing bold text: ${e.message}")
            e.printStackTrace()
        }
    }
    
    // Process inline code (`code`)
    private fun processInlineCode(
        originalText: String, 
        resultText: StringBuilder, 
        ranges: MutableList<FormattingRange>,
        context: Context
    ) {
        try {
            // Match single backtick code only (not triple backticks)
            val pattern = Pattern.compile("`([^`]+?)`")
            val matcher = pattern.matcher(originalText)
            
            // Get colors from resources or use defaults
            val bgColor = ContextCompat.getColor(context, R.color.inline_code_bg) 
                ?: Color.parseColor("#f5f5f5")
            val fgColor = ContextCompat.getColor(context, R.color.inline_code_fg) 
                ?: Color.parseColor("#e83e8c")
            
            var offset = 0
            while (matcher.find()) {
                val originalStart = matcher.start()
                val originalEnd = matcher.end()
                var innerText = matcher.group(1) ?: continue
                
                // Handle escaped newlines in the inline code content
                if (innerText.contains("\\n")) {
                    innerText = innerText.replace("\\n", "\n")
                }
                
                Log.d(TAG, "Inline code match: '$innerText'")
                
                // Calculate positions in the modified text
                val adjustedStart = originalStart - offset
                val adjustedEnd = originalEnd - offset
                
                // Make sure the span will be valid
                if (adjustedStart < 0 || adjustedEnd > resultText.length || adjustedStart > adjustedEnd) {
                    Log.e(TAG, "Invalid inline code range: $adjustedStart to $adjustedEnd in text length ${resultText.length}")
                    continue
                }
                
                ranges.add(FormattingRange(
                    adjustedStart, 
                    adjustedStart + innerText.length, 
                    FormattingType.INLINE_CODE,
                    bgColor,
                    fgColor
                ))
                
                resultText.replace(adjustedStart, adjustedEnd, innerText)
                offset += 2 // Length of two backticks
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error processing inline code: ${e.message}")
            e.printStackTrace()
        }
    }
    
    // Find and remove code blocks from the main text
    private fun removeCodeBlocks(
        originalText: String, 
        resultText: StringBuilder, 
        ranges: MutableList<FormattingRange>
    ) {
        try {
            // Match triple backtick blocks
            val pattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
            val matcher = pattern.matcher(originalText)
            
            var offset = 0
            while (matcher.find()) {
                val originalStart = matcher.start()
                val originalEnd = matcher.end()
                
                Log.d(TAG, "Found code block: ${matcher.group(0)}")
                
                // Calculate positions in the modified text
                val adjustedStart = originalStart - offset
                val adjustedEnd = originalEnd - offset
                
                // Make sure the range is valid
                if (adjustedStart < 0 || adjustedEnd > resultText.length || adjustedStart >= adjustedEnd) {
                    Log.e(TAG, "Invalid code block range: $adjustedStart to $adjustedEnd in text length ${resultText.length}")
                    continue
                }
                
                // Add a placeholder for where the code block was
                ranges.add(FormattingRange(
                    adjustedStart, 
                    adjustedStart, 
                    FormattingType.CODE_BLOCK_REMOVED
                ))
                
                // Remove the entire code block from the text
                resultText.replace(adjustedStart, adjustedEnd, "")
                offset += originalEnd - originalStart
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error removing code blocks: ${e.message}")
            e.printStackTrace()
        }
    }
    
    // Apply spans to the text
    private fun applySpans(
        spannableString: SpannableString, 
        ranges: List<FormattingRange>
    ) {
        try {
            for (range in ranges) {
                // Double-check that the range is valid
                if (range.start < 0 || range.end > spannableString.length || range.start > range.end) {
                    Log.e(TAG, "Invalid span range: ${range.start}...${range.end} for text length ${spannableString.length}")
                    continue
                }
                
                when (range.type) {
                    FormattingType.BOLD -> {
                        if (range.end <= spannableString.length) {
                            spannableString.setSpan(
                                StyleSpan(Typeface.BOLD),
                                range.start,
                                range.end,
                                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                            )
                        }
                    }
                    FormattingType.INLINE_CODE -> {
                        if (range.end <= spannableString.length) {
                            // Apply background color
                            spannableString.setSpan(
                                BackgroundColorSpan(range.bgColor),
                                range.start,
                                range.end,
                                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                            )
                            
                            // Apply text color
                            spannableString.setSpan(
                                ForegroundColorSpan(range.fgColor),
                                range.start,
                                range.end,
                                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                            )
                            
                            // Use TypefaceSpan for monospace font instead of StyleSpan(Typeface.MONOSPACE)
                            spannableString.setSpan(
                                TypefaceSpan("monospace"),
                                range.start,
                                range.end,
                                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                            )
                        }
                    }
                    FormattingType.CODE_BLOCK_REMOVED -> {
                        // No spans needed, the code block is handled separately
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error applying spans: ${e.message}")
            e.printStackTrace()
        }
    }
    
    // Process code blocks with syntax highlighting
    private fun processCodeBlocks(text: String, itemView: View) {
        try {
            val codeBlocksContainer = itemView.findViewById<LinearLayout>(R.id.code_blocks_container)
            if (codeBlocksContainer == null) {
                Log.e(TAG, "Code blocks container not found in layout")
                return
            }
            
            // Clear any existing code blocks
            codeBlocksContainer.removeAllViews()
            
            // Pattern to match code blocks with optional language identifier
            val pattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
            val matcher = pattern.matcher(text)
            
            while (matcher.find()) {
                val language = matcher.group(1) ?: ""
                var codeContent = matcher.group(2) ?: ""
                
                // Handle escaped newlines in the code content
                if (codeContent.contains("\\n")) {
                    codeContent = codeContent.replace("\\n", "\n")
                }
                
                Log.d(TAG, "Code block match - Language: '$language', Content length: ${codeContent.length}")
                
                // Create code block view
                val codeBlockView = createCodeBlockView(
                    itemView.context,
                    codeBlocksContainer,
                    language,
                    codeContent.trim()
                )
                
                // Add to container
                codeBlocksContainer.addView(codeBlockView)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error processing code blocks: ${e.message}")
            e.printStackTrace()
        }
    }
    
    // Create a code block view with syntax highlighting
    private fun createCodeBlockView(
        context: Context,
        container: LinearLayout,
        language: String,
        code: String
    ): View {
        try {
            // Inflate code block layout
            val codeBlockView = LayoutInflater.from(context)
                .inflate(R.layout.item_code_block, container, false)
            
            // Get views
            val languageLabel = codeBlockView.findViewById<TextView>(R.id.code_language_label)
            val copyButton = codeBlockView.findViewById<Button>(R.id.copy_code_button)
            val codeView = codeBlockView.findViewById<CodeView>(R.id.code_view)
            
            if (languageLabel == null || copyButton == null || codeView == null) {
                Log.e(TAG, "Missing views in code block layout")
                return TextView(context).apply { 
                    text = code
                    typeface = Typeface.MONOSPACE 
                }
            }
            
            // Set language label
            val displayLanguage = if (language.isNotEmpty()) language else "plaintext"
            languageLabel.text = displayLanguage
            
            // Set up copy button
            copyButton.setOnClickListener {
                val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Code Snippet", code)
                clipboard.setPrimaryClip(clip)
                Toast.makeText(context, "Code copied to clipboard", Toast.LENGTH_SHORT).show()
            }
            
            // Add drawable to copy button if available
            try {
                val drawableId = R.drawable.ic_copy
                copyButton.setCompoundDrawablesWithIntrinsicBounds(drawableId, 0, 0, 0)
            } catch (e: Exception) {
                Log.e(TAG, "Error setting copy icon: ${e.message}")
            }
            
            // Configure code view with syntax highlighting
            try {
                val actualLanguage = if (language.isEmpty()) "text" else language
                codeView.setOptions(Options.Default.get(context)
                    .withLanguage(actualLanguage)
                    .withTheme(ColorTheme.DEFAULT)
                    .withCode(code))
            } catch (e: Exception) {
                Log.e(TAG, "Error setting code options: ${e.message}")
                // Fallback: just set the code as text
                codeView.setCode(code)
            }
            
            return codeBlockView
        } catch (e: Exception) {
            Log.e(TAG, "Error creating code block view: ${e.message}")
            e.printStackTrace()
            
            // Fallback: return a simple TextView with the code
            return TextView(context).apply {
                text = code
                typeface = Typeface.MONOSPACE
                setPadding(16, 16, 16, 16)
                setBackgroundColor(Color.parseColor("#f5f5f5"))
            }
        }
    }

    private class MessageDiffCallback : DiffUtil.ItemCallback<Message>() {
        override fun areItemsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem.id == newItem.id
        }
        override fun areContentsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem == newItem
        }
    }
    
    companion object {
        private const val VIEW_TYPE_USER = 0
        private const val VIEW_TYPE_BOT = 1
        private const val VIEW_TYPE_ERROR = 2
        private const val VIEW_TYPE_BOT_WITH_IMAGE = 3
    }
}