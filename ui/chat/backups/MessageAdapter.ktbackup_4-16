package com.example.lilotest.ui.chat

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Color
import android.graphics.Typeface
import android.text.SpannableString
import android.text.Spanned
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.util.Base64
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import java.util.regex.Pattern
import android.os.Build
import android.annotation.SuppressLint

class MessageAdapter : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {
    private val TAG = "MessageAdapter"

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {
        val layoutId = when (viewType) {
            VIEW_TYPE_USER -> R.layout.item_message_user
            VIEW_TYPE_BOT_WITH_IMAGE -> R.layout.item_message_bot_with_image
            VIEW_TYPE_BOT -> R.layout.item_message_bot
            else -> R.layout.item_message_error
        }

        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false)
        return MessageViewHolder(view)
    }

    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)
            
        try {
            // Get the message content safely
            val content = message.content ?: ""

            Log.d(TAG, "Processing message ID ${message.id}, content length: ${content.length}")



            // Check for code parts
            val hasCodeBlocks = content.contains("```")

            if (hasCodeBlocks) {
                // Process code parts
                processMessageWithInlineCodeBlocks(content, holder, message)
            } else {
                // Use text response for other parts
                val formattedText = formatTextWithoutCodeBlocks(content, holder.itemView.context) 

                // Make sure regular text view has content
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = formattedText
                }

                // Set timestamp
                holder.setTimestamp(message.timestamp)
            }

            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE

                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Loading from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(RequestOptions()
                                .diskCacheStrategy(DiskCacheStrategy.ALL)
                                .error(R.drawable.ic_error_placeholder))
                            .into(imageView)
                            .clearOnDetach()

                        progressBar.visibility = View.GONE
                        
                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base 64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image data
                                val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try decoding directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } 
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()

            // Fallback to text binding
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = message.content ?: ""
            }
            holder.setTimestamp(message.timestamp)
        }
    }
         
    override fun getItemViewType(position: Int): Int {
        val message = getItem(position)
        return when {
            message.type == MessageType.USER -> VIEW_TYPE_USER
            message.type == MessageType.BOT && message.containsImage -> VIEW_TYPE_BOT_WITH_IMAGE
            message.type == MessageType.BOT -> VIEW_TYPE_BOT
            else -> VIEW_TYPE_ERROR
        }
    }

    // New method to process message with inline code blocks

    private fun processMessageWithInlineCodeBlocks(messageText: String, holder: MessageViewHolder, message: Message) {

        try {
            // Hide the regular Content TextView since we'll be using the container
            holder.getContentTextView()?.visibility = View.GONE

            // Get the content container
            val contentContainer = holder.getContentContainer()
            if (contentContainer == null) {
                Log.e(TAG, "Content container not found in layout")
                // Fallback to regular TextView if container not found
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = messageText
                }
                holder.setTimestamp(message.timestamp)
                return
            }

            // Make container visible
            contentContainer.visibility = View.VISIBLE
 
            // Clear content container
            contentContainer.removeAllViews()

            // Find all code blocks 
            val codeBlocks = findCodeBlocks(messageText)
            Log.d(TAG, "Found ${codeBlocks.size} code blocks in message")

            if (codeBlocks.isEmpty()) {
                //If no code blocks are found format text normally
                val formattedText = formatTextWithoutCodeBlocks(messageText, holder.itemView.context)
                val textView = createTextView(holder.itemView.context, formattedText)
                contentContainer.addView(textView)
            } else {
                
                var lastPosition = 0

                val sortedCodeBlocks = codeBlocks.sortedBy { it.startPosition }
                for (codeBlock in sortedCodeBlocks) {

                    if (codeBlock.startPosition > lastPosition) {
                        val textBefore = messageText.substring(lastPosition, codeBlock.startPosition)
                        if (textBefore.isNotEmpty()) {
                            val formattedText = formatTextWithoutCodeBlocks(textBefore, holder.itemView.context)
                            val textView = createTextView(holder.itemView.context, formattedText)
                            contentContainer.addView(textView)
                        }
                    }
                    // Add code block
                    val codeBlockView = createCodeBlockView(
                        holder.itemView.context,
                        codeBlock.language,
                        codeBlock.code
                    )
                    contentContainer.addView(codeBlockView)

                    // Update last position
                    lastPosition = codeBlock.endPosition
                }
                // Add remaining text after the last code block
                if (lastPosition < messageText.length) {
                    val textAfter = messageText.substring(lastPosition)
                    if (textAfter.isNotEmpty()) {
                        val formattedText = formatTextWithoutCodeBlocks(textAfter, holder.itemView.context)
                        val textView = createTextView(holder.itemView.context, formattedText)
                        contentContainer.addView(textView)
                    }
                }
            }
            // Set the timestamp
            holder.setTimestamp(message.timestamp)
            
            // Hide the old code blocks container and replace with inline code
            holder.getCodeBlocksContainer()?.visibility = View.GONE
            
        } catch (e: Exception) {
            Log.e(TAG, "Error processing message with inline code blocks: ${e.message}")
            e.printStackTrace()

            // Fallback to simple TextView
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = messageText
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    // Create text view for text content
    private fun createTextView(context: Context, text: SpannableString): TextView {
        val textView = TextView(context)
        textView.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        textView.textSize = 16f
        textView.text = text
        return textView
    }

    // Data class to store code block info
    private data class CodeBlock(
        val language: String,
        val code: String,
        val startPosition: Int,
        val endPosition: Int
    )




    // Find all text in code blocks and find their positions
    private fun findCodeBlocks(text: String): List<CodeBlock> {
        val codeBlocks = mutableListOf<CodeBlock>()

        // Finding match for code blocks with language identifier
        try {
            val pattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
            val matcher = pattern.matcher(text)

            while (matcher.find()) {
                val language = matcher.group(1) ?: ""
                var codeContent = matcher.group(2) ?: ""
     
                // Handle escaped newlines in the code content
                if (codeContent.contains("\\n")) {
                    codeContent = codeContent.replace("\\n", "\n")
                }

                Log.d(TAG, "Found code block: language=$language, position=${matcher.start()}-${matcher.end()}")

                codeBlocks.add(
                    CodeBlock(
                        language = language,
                        code = codeContent.trim(),
                        startPosition = matcher.start(),
                        endPosition = matcher.end()
                    )
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding code blocks: ${e.message}.")
            e.printStackTrace()
        }
        return codeBlocks
    }  

    private fun formatTextWithoutCodeBlocks(text: String, context: Context): SpannableString {
        try {
            // Process bold text
            val boldPattern = Pattern.compile("\\*\\*(.*?)\\*\\*")
            val boldMatcher = boldPattern.matcher(text)

            // Find bold matches and collect them
            val boldMatches = mutableListOf<Triple<Int, Int, String>>()
            while (boldMatcher.find()) {
                boldMatches.add(Triple(
                    boldMatcher.start(),
                    boldMatcher.end(),
                    boldMatcher.group(1) ?: ""
                ))
            }

            // Create a new string with bold markers removed
            val resultText = StringBuilder(text)
            var offset = 0
            for ((start, end, innerText) in boldMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = end - offset
                resultText.replace(adjustedStart, adjustedEnd, innerText)
                offset += 4 // Remove asterisks
            }

            // Create spannable with modified text
            val result = SpannableString(resultText.toString())

            // Apply bold formatting
            offset = 0
            for ((start, end, innerText) in boldMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = adjustedStart + innerText.length
                
                result.setSpan(
                    StyleSpan(Typeface.BOLD),
                    adjustedStart,
                    adjustedEnd,
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                offset += 4
            }

            // Process inlineCode
            val inlineCodePattern = Pattern.compile("`([^`]+?)`")
            val inlineCodeMatcher = inlineCodePattern.matcher(result.toString())

            // Get colors from resources 
            val bgColor = ContextCompat.getColor(context, R.color.inline_code_bg)
                ?: Color.parseColor("#f5f5f5")
            val fgColor = ContextCompat.getColor(context, R.color.inline_code_fg)
                ?: Color.parseColor("#e83e8c")

            // Find all inline code matches and collect them
            val codeMatches = mutableListOf<Triple<Int, Int, String>>()
            while (inlineCodeMatcher.find()) {
                var innerText = inlineCodeMatcher.group(1) ?: continue
                
                // Handle newlines
                if (innerText.contains("\\n")) {
                    innerText = innerText.replace("\\n", "\n")
                }

                codeMatches.add(Triple(
                    inlineCodeMatcher.start(),
                    inlineCodeMatcher.end(),
                    innerText
                ))
            }

            // If no inline code return result with bold formatting
            if (codeMatches.isEmpty()) {
                return result
            }

            // Create a new string with inline backticks removed
            val finalText = StringBuilder(result.toString())
            offset = 0

            for ((start, end, innerText) in codeMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = end - offset
                finalText.replace(adjustedStart, adjustedEnd, innerText)
                offset += 2  // remove backticks
            }

            // Create final spannable with all formatting
            val finalResult = SpannableString(finalText.toString())

            // Copy existing bold spans
            val spans = result.getSpans(0, result.length, StyleSpan::class.java)
            for (span in spans) {
                val spanStart = result.getSpanStart(span)
                val spanEnd = result.getSpanEnd(span)
                val spanFlags = result.getSpanFlags(span)

                // Adjust position for any spans that might be affected by inline code removal
                var adjustedStart = spanStart
                var adjustedEnd = spanEnd
                
                // if spans starts after inline codeblock
                for ((start, end, innerText) in codeMatches) {
                    if (spanStart > end) {
                        adjustedStart -= 0 // Two removed backticks
                    }
                    // if spans starts before inline codeblock
                    if (spanEnd > end) {
                        adjustedEnd -= 0 
                    }
                }

                if (adjustedStart < adjustedEnd && adjustedEnd <= finalResult.length) {
                    finalResult.setSpan(span, adjustedStart, adjustedEnd, spanFlags)
                }
            }
            // Apply inline code formatting
            offset = 0
            for ((start, end, innerText) in codeMatches) {
                val adjustedStart = start - offset
                val adjustedEnd = adjustedStart + innerText.length

                if (adjustedStart < adjustedEnd && adjustedEnd <= finalResult.length) {
                    // Apply background color
                    finalResult.setSpan(
                        BackgroundColorSpan(bgColor),
                        adjustedStart,
                        adjustedEnd,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                   
                    // Apply text color
                    finalResult.setSpan(
                        ForegroundColorSpan(fgColor),
                        adjustedStart,
                        adjustedEnd,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )

                    // Apply monospace font
                    finalResult.setSpan(
                        TypefaceSpan("monospace"),
                        adjustedStart,
                        adjustedEnd,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
                offset += 2

            }
            return finalResult

        } catch (e: Exception) {
            Log.e(TAG, "Error formatting text: ${e.message}")
            e.printStackTrace()
            return SpannableString(text)
        }
    }



    // Create code block with syntax highlighter
    private fun createCodeBlockView(
        context: Context,
        language: String,
        code: String
    ): View {
        try {
            //Inflate code block layout
            val codeBlockView = LayoutInflater.from(context)
                .inflate(R.layout.item_code_block, null, false)

            // Set layout parameters
            codeBlockView.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            // Get views
            val languageLabel = codeBlockView.findViewById<TextView>(R.id.code_language_label)
            val copyButton = codeBlockView.findViewById<Button>(R.id.copy_code_button)
            val codeView = codeBlockView.findViewById<CodeView>(R.id.code_view)

            if (languageLabel == null || copyButton == null || codeView == null) {
                Log.e(TAG, "Missing views in code block layout")
                return TextView(context).apply {
                    text = code
                    typeface = Typeface.MONOSPACE
                }
            }
            // Set language label
            val displayLanguage = if (language.isNotEmpty()) language else "plaintext"
            languageLabel.text = displayLanguage

            // Set up copy button
            copyButton.setOnClickListener {
                val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Code Snippet", code)
                clipboard.setPrimaryClip(clip)
                Toast.makeText(context, "Code copied to clipboard", Toast.LENGTH_SHORT).show()
            }

            // Add drawable to copy button if available
            try {
                val drawableId = R.drawable.ic_copy
                copyButton.setCompoundDrawablesWithIntrinsicBounds(drawableId, 0, 0, 0)
            } catch (e: Exception) {
                Log.e(TAG, "Error setting copy icon: ${e.message}")
            }
                 
            // Configure code view with syntax highlighting
            try {
                val actualLanguage = if (language.isEmpty()) "text" else language
                codeView.setOptions(Options.Default.get(context)
                    .withLanguage(actualLanguage)
                    .withTheme(ColorTheme.DEFAULT)
                    .withCode(code))
            } catch (e: Exception) {
                Log.e(TAG, "Error setting code options: ${e.message}")
                codeView.setCode(code)
            }
            return codeBlockView
        } catch (e: Exception) {
            Log.e(TAG, "Error creating code block view: ${e.message}")
            e.printStackTrace()

            // Fallback: Return a simple TextView with the code
            return TextView(context).apply {
                text = code
                typeface = Typeface.MONOSPACE
                setPadding(16, 16, 16, 16)
                setBackgroundColor(Color.parseColor("#f5f5f5"))
            }
        }
    }
    private class MessageDiffCallback : DiffUtil.ItemCallback<Message>() {
        override fun areItemsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem.id == newItem.id
        }
        override fun areContentsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem == newItem
        }
    }

    companion object {
        private const val VIEW_TYPE_USER = 0
        private const val VIEW_TYPE_BOT = 1
        private const val VIEW_TYPE_ERROR = 2
        private const val VIEW_TYPE_BOT_WITH_IMAGE = 3
    }
}