package com.example.lilotest.ui.chat

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Color
import android.graphics.Typeface
import android.text.SpannableString
import android.text.Spanned
import android.text.method.LinkMovementMethod
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.text.style.RelativeSizeSpan

import android.util.Base64
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.HorizontalScrollView
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.webkit.WebView
import android.webkit.WebSettings
import android.widget.Toast
import android.widget.TableLayout
import android.os.Build
import android.text.style.CharacterStyle
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import io.noties.markwon.Markwon
import io.noties.markwon.recycler.table.TableEntry
import io.noties.markwon.recycler.table.TableEntryPlugin
import io.noties.markwon.ext.tables.TableTheme
import io.noties.markwon.html.HtmlPlugin
import io.noties.markwon.ext.tables.TablePlugin
import android.text.util.Linkify
import androidx.core.text.clearSpans
import io.noties.markwon.ext.tables.TableAwareMovementMethod
import io.noties.markwon.movement.MovementMethodPlugin
import java.util.regex.Pattern
import java.util.regex.Matcher

class MessageAdapter : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {
    private val TAG = "MessageAdapter"

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {
        val layoutId = when (viewType) {
            VIEW_TYPE_USER -> R.layout.item_message_user
            VIEW_TYPE_BOT_WITH_IMAGE -> R.layout.item_message_bot_with_image
            VIEW_TYPE_BOT -> R.layout.item_message_bot
            else -> R.layout.item_message_error
        }

        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false)
        return MessageViewHolder(view)
    }

    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)

        try {
            // Get the message content safely
            val content = message.content ?: ""

            Log.d(TAG, "Processing message ID ${message.id}, content length: ${content.length}")

            // Check for code blocks or tables
            val hasSpecialBlocks = content.contains("```") || containsMarkdownTable(content)

            if (hasSpecialBlocks) {
                // Process content with special blocks
                processMessageWithSpecialBlocks(content, holder, message)
            } else {
                // Use text response for other parts
                val formattedText = formatTextWithoutCodeBlocks(content, holder.itemView.context)

                // Make sure regular text view has content
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = formattedText
                }

                // Set timestamp
                holder.setTimestamp(message.timestamp)
            }

            // Process images (unchanged)
            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE

                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Loading from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(RequestOptions()
                                .diskCacheStrategy(DiskCacheStrategy.ALL)
                                .error(R.drawable.ic_error_placeholder))
                            .into(imageView)
                            .clearOnDetach()

                        progressBar.visibility = View.GONE

                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base 64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image data
                                val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try decoding directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            }
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()

            // Fallback to text binding
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = message.content ?: ""
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    override fun getItemViewType(position: Int): Int {
        val message = getItem(position)
        return when {
            message.type == MessageType.USER -> VIEW_TYPE_USER
            message.type == MessageType.BOT && message.containsImage -> VIEW_TYPE_BOT_WITH_IMAGE
            message.type == MessageType.BOT -> VIEW_TYPE_BOT
            else -> VIEW_TYPE_ERROR
        }
    }

    // Checks if the message contains a markdown table
    private fun containsMarkdownTable(text: String): Boolean {
        val pattern = Pattern.compile("\\|(.+?)\\|[\\s\\S]*?\\|", Pattern.DOTALL)
        val matcher = pattern.matcher(text)
        return matcher.find()
    }

    // Helper method to create a TableTheme
    private fun createTableTheme(context: Context): TableTheme {
        return TableTheme.Builder()
            //.tableBorderColor(ContextCompat.getColor(context, R.color.table3))
            .tableBorderColor(Color.TRANSPARENT)
            .tableBorderWidth(0)
            .tableCellPadding(8)
            .tableHeaderRowBackgroundColor(ContextCompat.getColor(context, R.color.table_header_bg))
            .build()
            //.tableEvenRowBackgroundColor(ContextCompat.getColor(context, R.color.table1))
            //.tableOddRowBackgroundColor(ContextCompat.getColor(context, R.color.white))
    }


    private fun processMarkdownTable(tableText: String, context: Context): View {
        return try {
            Log.d(TAG, "Processing markdown table: ${tableText.take(50)}...")
            
            // 1. Create container for table and button
            val container = LinearLayout(context).apply {
                orientation = LinearLayout.VERTICAL
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
                setBackgroundColor(ContextCompat.getColor(context, R.color.table4))
                setPadding(0, 8.dpToPx(context), 0, 8.dpToPx(context))
            }

            // 2. Create header bar with copy button
            val headerBar = LinearLayout(context).apply {
                orientation = LinearLayout.HORIZONTAL
                setBackgroundColor(ContextCompat.getColor(context, R.color.table3))
                setPadding(8.dpToPx(context), 8.dpToPx(context), 8.dpToPx(context), 8.dpToPx(context))
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
            }

            // Add table label
            headerBar.addView(TextView(context).apply {
                text = "TABLE"
                setTypeface(null, Typeface.BOLD)
                setTextColor(Color.parseColor("#495057"))
            })

            // Add spacer
            headerBar.addView(View(context).apply {
                layoutParams = LinearLayout.LayoutParams(0, 1, 1f)
            })

            // Add copy button
            headerBar.addView(Button(context, null, 0, R.style.CopyButtonStyle).apply {
                text = "Copy"
                setOnClickListener {
                    val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                    val clip = ClipData.newPlainText("Table", tableText)
                    clipboard.setPrimaryClip(clip)
                    Toast.makeText(context, "Table copied", Toast.LENGTH_SHORT).show()
                }
            })

            // 3. Convert markdown table to HTML
            val htmlTable = convertMarkdownTableToHtml(tableText)
            Log.d(TAG, "Converted HTML table:\n$htmlTable")

            // 4. Create WebView with optimized settings
            val webView = WebView(context).apply {
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                ).apply {
                    height = ViewGroup.LayoutParams.WRAP_CONTENT
                }

                settings.apply {
                    javaScriptEnabled = false
                    loadWithOverviewMode = true
                    useWideViewPort = true
                    layoutAlgorithm = WebSettings.LayoutAlgorithm.TEXT_AUTOSIZING
                    setSupportZoom(false)
                    builtInZoomControls = false
                    displayZoomControls = false
                    cacheMode = WebSettings.LOAD_NO_CACHE
                }

                isVerticalScrollBarEnabled = false
                isHorizontalScrollBarEnabled = true
                setBackgroundColor(Color.TRANSPARENT)
                setLayerType(View.LAYER_TYPE_HARDWARE, null)
            }

            // 5. Create HTML document with responsive styling
            val html = """
            <!DOCTYPE html>
            <html>
            <head>
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body {
                        margin: 0;
                        padding: 0;
                        width: 100%;
                    }
                    table {
                        border-collapse: collapse;
                        width: 100%;
                        margin: 0;
                        padding: 0;
                    }
                    th, td {
                        border: 1px solid #dee2e6;
                        padding: 8px;
                        text-align: left;
                    }
                    th {
                        background-color: #e9ecef;
                        position: sticky;
                        top: 0;
                    }
                    tr:nth-child(even) {
                        background-color: #f8f9fa;
                    }
                    tr:nth-child(odd) {
                        background-color: #ffffff;
                    }
                </style>
            </head>
            <body>
                ${convertMarkdownTableToHtml(tableText)}
            </body>
            </html>
            """.trimIndent()

            // 6. Create scroll container
            val scrollView = HorizontalScrollView(context).apply {
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
                overScrollMode = View.OVER_SCROLL_ALWAYS
                isFillViewport = true
            }

            // 7. Load HTML into WebView
            webView.loadDataWithBaseURL(
                null, 
                html,
                "text/html", 
                "UTF-8", 
                null
            )

            // 8. Add views to container
            scrollView.addView(webView)
            container.addView(headerBar)
            container.addView(scrollView)

            container
        } catch (e: Exception) {
            Log.e(TAG, "Error rendering table", e)
            TextView(context).apply {
                text = "Table rendering failed. Raw content:\n\n$tableText"
            }
        }
    }


    private fun convertMarkdownTableToHtml(markdownTable: String): String {
        try {
            val lines = markdownTable.trim().split("\n")
                .map { it.trim() }
                .filter { it.isNotEmpty() && it.startsWith("|") }

            if (lines.size < 2) return "<p>Invalid table format</p>"

            val html = StringBuilder().apply {
                append("<table style=\"border-collapse: collapse; width: 100%;\">")
                
                // Process header row
                append("<tr style=\"background-color: #e9ecef;\">")
                lines[0].trim('|').split("|")
                    .map { it.trim() }
                    .forEach { cell ->
                        append("<th style=\"border: 1px solid #dee2e6; padding: 8px;\">")
                        append(processCellContent(cell))
                        append("</th>")
                    }
                append("</tr>")
                
                // Process data rows
                lines.drop(2).forEachIndexed { index, line ->
                    val bgColor = if (index % 2 == 0) "#f8f9fa" else "#ffffff"
                    append("<tr style=\"background-color: $bgColor;\">")
                    line.trim('|').split("|")
                        .map { it.trim() }
                        .forEach { cell ->
                            append("<td style=\"border: 1px solid #dee2e6; padding: 8px;\">")
                            append(processCellContent(cell))
                            append("</td>")
                        }
                    append("</tr>")
                }
                
                append("</table>")
            }
            
            return html.toString()
        } catch (e: Exception) {
            Log.e(TAG, "Error converting table to HTML", e)
            return "<p>Error processing table</p>"
        }
    }

    private fun processCellContent(cellText: String): String {
        return cellText
            .replace(Regex("\\*\\*(.*?)\\*\\*")) { "<strong>${it.groupValues[1]}</strong>" }
            .replace(Regex("_(.*?)_")) { "<em>${it.groupValues[1]}</em>" }
            .replace(Regex("`(.*?)`")) { 
                "<code style=\"background: #f5f5f5; padding: 2px 4px; border-radius: 3px;\">${it.groupValues[1]}</code>" 
            }
            .replace(Regex("^\\* ")) { matchResult -> 
                "• " 
            }
    }

    private fun Int.dpToPx(context: Context): Int {
        return (this * context.resources.displayMetrics.density).toInt()
    }


    // Process message with special blocks (code blocks and tables)
    private fun processMessageWithSpecialBlocks(messageText: String, holder: MessageViewHolder, message: Message) {
        try {
            // Hide the regular Content TextView since we'll be using the container
            holder.getContentTextView()?.visibility = View.GONE

            // Get the content container
            val contentContainer = holder.getContentContainer()
            if (contentContainer == null) {
                Log.e(TAG, "Content container not found in layout")
                // Fallback to regular TextView if container not found
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = messageText
                }
                holder.setTimestamp(message.timestamp)
                return
            }

            // Make container visible
            contentContainer.visibility = View.VISIBLE

            // Clear content container
            contentContainer.removeAllViews()

            // Find all code blocks
            val codeBlocks = findCodeBlocks(messageText)
            Log.d(TAG, "Found ${codeBlocks.size} code blocks in message")

            // Find all table blocks
            val tableBlocks = findTableBlocks(messageText)
            Log.d(TAG, "Found ${tableBlocks.size} table blocks in message")

            // Combine both types of blocks and sort by position
            val allBlocks = (codeBlocks + tableBlocks).sortedBy { it.startPosition }

            if (allBlocks.isEmpty()) {
                // If no special blocks are found, format text normally
                val formattedText = formatTextWithoutCodeBlocks(messageText, holder.itemView.context)
                val textView = createTextView(holder.itemView.context, formattedText)
                contentContainer.addView(textView)
            } else {
                var lastPosition = 0

                for (block in allBlocks) {
                    // Add text before the block
                    if (block.startPosition > lastPosition) {
                        val textBefore = messageText.substring(lastPosition, block.startPosition)
                        if (textBefore.isNotEmpty()) {
                            val formattedText = formatTextWithoutCodeBlocks(textBefore, holder.itemView.context)
                            val textView = createTextView(holder.itemView.context, formattedText)
                            contentContainer.addView(textView)
                        }
                    }

                    // Add the block based on its type
                    if (block.language == "table") {
                        // This is a table block
                        val tableView = processMarkdownTable(block.code, holder.itemView.context)
                        contentContainer.addView(tableView)
                    } else {
                        // This is a code block
                        val codeBlockView = createCodeBlockView(
                            holder.itemView.context,
                            block.language,
                            block.code
                        )
                        contentContainer.addView(codeBlockView)
                    }

                    // Update last position
                    lastPosition = block.endPosition
                }

                // Add remaining text after the last block
                if (lastPosition < messageText.length) {
                    val textAfter = messageText.substring(lastPosition)
                    if (textAfter.isNotEmpty()) {
                        val formattedText = formatTextWithoutCodeBlocks(textAfter, holder.itemView.context)
                        val textView = createTextView(holder.itemView.context, formattedText)
                        contentContainer.addView(textView)
                    }
                }
            }

            // Set the timestamp
            holder.setTimestamp(message.timestamp)

            // Hide the old code blocks container
            holder.getCodeBlocksContainer()?.visibility = View.GONE

        } catch (e: Exception) {
            Log.e(TAG, "Error processing message with special blocks: ${e.message}")
            e.printStackTrace()

            // Fallback to simple TextView
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = messageText
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    // Create text view for text content
    private fun createTextView(context: Context, text: SpannableString): TextView {
        val textView = TextView(context)
        textView.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        textView.textSize = 16f
        textView.text = text
        return textView
    }

    // Data class to store block info (for both code and tables)
    private data class CodeBlock(
        val language: String,
        val code: String,
        val startPosition: Int,
        val endPosition: Int
    )

    // Advanced table detection to better handle your specific table format
    private fun findTableBlocks(text: String): List<CodeBlock> {
        val tableBlocks = mutableListOf<CodeBlock>()

        try {
            // Pattern for standard markdown tables (header row, separator row, data rows)
            val tablePattern = Pattern.compile(
                "^\\|(.+?)\\|\\s*\\n" +  // Header row
                "\\|([-:]+\\|[-:\\s|]+)+\\s*\\n" +  // Separator row
                "(\\|.+?\\|\\s*\\n)+",  // Data rows
                Pattern.MULTILINE
            )
            val matcher = tablePattern.matcher(text)

            // First check for standard tables
            while (matcher.find()) {
                val tableText = matcher.group(0) ?: continue  
                if (!isPositionInsideCodeBlock(text, matcher.start())) {
                    tableBlocks.add(
                        CodeBlock(
                            language = "table",
                            code = tableText.trim(),
                            startPosition = matcher.start(),
                            endPosition = matcher.end()
                        )
                    )
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding table blocks: ${e.message}")
            e.printStackTrace()
        }

        return tableBlocks
    }

    private fun formatTextWithoutCodeBlocks(text: String, context: Context): SpannableString {
        try {
            // Process bullet points first (before creating SpannableString)
            // Replace "* " at the beginning of lines with a bullet character
            val bulletPattern = Pattern.compile("(?m)^\\s*\\* ")
            val bulletMatcher = bulletPattern.matcher(text)
            val bulletText = bulletMatcher.replaceAll("• ")

            // Create a SpannableString with the bullet-replaced text
            val spannableString = SpannableString(bulletText)
            
            // Process headers (# Text, ## Text, ### Text)
            // Match headers at the beginning of lines
            val headerPattern = Pattern.compile("(?m)^(#{1,3})\\s+([^\\n]+)")
            val headerMatcher = headerPattern.matcher(bulletText)
            while (headerMatcher.find()) {
                val headerMarker = headerMatcher.group(1) ?: ""
                val headerText = headerMatcher.group(2) ?: ""
                
                // Calculate the span range - include the # characters and space
                val start = headerMatcher.start()
                val markerEnd = headerMatcher.start(2) // Start of header text
                val end = headerMatcher.end()
                
                // Apply appropriate header styling based on # count
                when (headerMarker.length) {
                    1 -> { // # - Largest header (1.5x)
                        // Apply header text style
                        spannableString.setSpan(
                            RelativeSizeSpan(1.5f),
                            markerEnd,
                            end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                        // Also make it bold
                        spannableString.setSpan(
                            StyleSpan(Typeface.BOLD),
                            markerEnd,
                            end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                    2 -> { // ## - Medium header (1.25x)
                        // Apply header text style
                        spannableString.setSpan(
                            RelativeSizeSpan(1.25f),
                            markerEnd,
                            end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                        // Also make it bold
                        spannableString.setSpan(
                            StyleSpan(Typeface.BOLD),
                            markerEnd,
                            end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                    3 -> { // ### - Small header (1.1x)
                        // Apply header text style
                        spannableString.setSpan(
                            RelativeSizeSpan(1.1f),
                            markerEnd,
                            end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                        // Also make it bold
                        spannableString.setSpan(
                            StyleSpan(Typeface.BOLD),
                            markerEnd,
                            end,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                }
                
                // Hide the header markers (the #s and the space)
                spannableString.setSpan(
                    ForegroundColorSpan(Color.TRANSPARENT),
                    start,
                    markerEnd,
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                )
            }
            
            // Process bold text (**text**)
            val boldPattern = Pattern.compile("\\*\\*(.*?)\\*\\*")
            val boldMatcher = boldPattern.matcher(bulletText)
            while (boldMatcher.find()) {
                val innerText = boldMatcher.group(1) ?: ""
                val start = boldMatcher.start()
                val end = boldMatcher.end()
                
                if (start < end && end <= bulletText.length) {
                    // Hide the ** markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        start,
                        start + 2,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Apply bold to the inner text
                    spannableString.setSpan(
                        StyleSpan(Typeface.BOLD),
                        start + 2,
                        end - 2,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Hide the ** markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        end - 2,
                        end,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
            }
            
            // Process italic text with asterisks (*text*)
            val italicAsteriskPattern = Pattern.compile("\\*([^*]+?)\\*")
            val italicAsteriskMatcher = italicAsteriskPattern.matcher(bulletText)
            while (italicAsteriskMatcher.find()) {
                val innerText = italicAsteriskMatcher.group(1) ?: ""
                val start = italicAsteriskMatcher.start()
                val end = italicAsteriskMatcher.end()
                
                // Make sure we're not inside a ** span (which would be bold)
                val isBold = isBoldSpan(bulletText, italicAsteriskMatcher.start())
                if (!isBold && start < end && end <= bulletText.length) {
                    // Hide the * markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        start,
                        start + 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Apply italic to the inner text
                    spannableString.setSpan(
                        StyleSpan(Typeface.ITALIC),
                        start + 1,
                        end - 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Hide the * markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        end - 1,
                        end,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
            }
            
            // Process italic text with underscores (_text_)
            val italicUnderscorePattern = Pattern.compile("_([^_]+?)_")
            val italicUnderscoreMatcher = italicUnderscorePattern.matcher(bulletText)
            while (italicUnderscoreMatcher.find()) {
                val innerText = italicUnderscoreMatcher.group(1) ?: ""
                val start = italicUnderscoreMatcher.start()
                val end = italicUnderscoreMatcher.end()
                
                if (start < end && end <= bulletText.length) {
                    // Hide the _ markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        start,
                        start + 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Apply italic to the inner text
                    spannableString.setSpan(
                        StyleSpan(Typeface.ITALIC),
                        start + 1,
                        end - 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Hide the _ markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        end - 1,
                        end,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
            }
            
            // Process inline code (`text`)
            val inlineCodePattern = Pattern.compile("`([^`]+?)`")
            val inlineCodeMatcher = inlineCodePattern.matcher(bulletText)
            
            // Get colors from resources
            val bgColor = ContextCompat.getColor(context, R.color.inline_code_bg)
                ?: Color.parseColor("#f5f5f5")
            val fgColor = ContextCompat.getColor(context, R.color.inline_code_fg)
                ?: Color.parseColor("#e83e8c")
                
            while (inlineCodeMatcher.find()) {
                var innerText = inlineCodeMatcher.group(1) ?: continue
                
                // Handle newlines
                if (innerText.contains("\\n")) {
                    innerText = innerText.replace("\\n", "\n")
                }
                
                val start = inlineCodeMatcher.start()
                val end = inlineCodeMatcher.end()
                
                if (start < end && end <= bulletText.length) {
                    // Hide the ` markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        start,
                        start + 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Apply background color
                    spannableString.setSpan(
                        BackgroundColorSpan(bgColor),
                        start + 1,
                        end - 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Apply text color
                    spannableString.setSpan(
                        ForegroundColorSpan(fgColor),
                        start + 1,
                        end - 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Apply monospace font
                    spannableString.setSpan(
                        TypefaceSpan("monospace"),
                        start + 1,
                        end - 1,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                    
                    // Hide the ` markers
                    spannableString.setSpan(
                        ForegroundColorSpan(Color.TRANSPARENT),
                        end - 1,
                        end,
                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
            }
            
            return spannableString
        } catch (e: Exception) {
            Log.e(TAG, "Error formatting text: ${e.message}")
            e.printStackTrace()
            return SpannableString(text)
        }
    }

    // Helper method to check if a position is inside a bold span
    private fun isBoldSpan(text: String, position: Int): Boolean {
        val boldPattern = Pattern.compile("\\*\\*(.*?)\\*\\*")
        val matcher = boldPattern.matcher(text)
        
        while (matcher.find()) {
            if (position >= matcher.start() && position <= matcher.end()) {
                return true
            }
        }
        
        return false
    }


    // Helper method to check if a position in text is inside a code block
    private fun isPositionInsideCodeBlock(text: String, position: Int): Boolean {
        val codeBlockPattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
        val matcher = codeBlockPattern.matcher(text)

        while (matcher.find()) {
            if (position >= matcher.start() && position <= matcher.end()) {
                return true
            }
        }

        return false
    }



    // Find all code blocks
    private fun findCodeBlocks(text: String): List<CodeBlock> {
        val codeBlocks = mutableListOf<CodeBlock>()

        // Finding match for code blocks with language identifier
        try {
            val pattern = Pattern.compile("```([a-zA-Z]*)\\s*([\\s\\S]*?)```", Pattern.DOTALL)
            val matcher = pattern.matcher(text)

            while (matcher.find()) {
                val language = matcher.group(1) ?: ""
                var codeContent = matcher.group(2) ?: ""

                // Handle escaped newlines in the code content
                if (codeContent.contains("\\n")) {
                    codeContent = codeContent.replace("\\n", "\n")
                }

                Log.d(TAG, "Found code block: language=$language, position=${matcher.start()}-${matcher.end()}")

                codeBlocks.add(
                    CodeBlock(
                        language = language,
                        code = codeContent.trim(),
                        startPosition = matcher.start(),
                        endPosition = matcher.end()
                    )
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding code blocks: ${e.message}.")
            e.printStackTrace()
        }
        return codeBlocks
    }


    // Create code block with syntax highlighter
    private fun createCodeBlockView(
        context: Context,
        language: String,
        code: String
    ): View {
        try {
            //Inflate code block layout
            val codeBlockView = LayoutInflater.from(context)
                .inflate(R.layout.item_code_block, null, false)

            // Set layout parameters
            codeBlockView.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            // Get views
            val languageLabel = codeBlockView.findViewById<TextView>(R.id.code_language_label)
            val copyButton = codeBlockView.findViewById<Button>(R.id.copy_code_button)
            val codeView = codeBlockView.findViewById<CodeView>(R.id.code_view)

            if (languageLabel == null || copyButton == null || codeView == null) {
                Log.e(TAG, "Missing views in code block layout")
                return TextView(context).apply {
                    text = code
                    typeface = Typeface.MONOSPACE
                }
            }
            // Set language label
            val displayLanguage = if (language.isNotEmpty()) language else "plaintext"
            languageLabel.text = displayLanguage

            // Set up copy button
            copyButton.setOnClickListener {
                val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Code Snippet", code)
                clipboard.setPrimaryClip(clip)
                Toast.makeText(context, "Code copied to clipboard", Toast.LENGTH_SHORT).show()
            }

            // Add drawable to copy button if available
            try {
                val drawableId = R.drawable.ic_copy
                copyButton.setCompoundDrawablesWithIntrinsicBounds(drawableId, 0, 0, 0)
            } catch (e: Exception) {
                Log.e(TAG, "Error setting copy icon: ${e.message}")
            }

            // Configure code view with syntax highlighting
            try {
                val actualLanguage = if (language.isEmpty()) "text" else language
                codeView.setOptions(Options.Default.get(context)
                    .withLanguage(actualLanguage)
                    .withTheme(ColorTheme.DEFAULT)
                    .withCode(code))
            } catch (e: Exception) {
                Log.e(TAG, "Error setting code options: ${e.message}")
                codeView.setCode(code)
            }
            return codeBlockView
        } catch (e: Exception) {
            Log.e(TAG, "Error creating code block view: ${e.message}")
            e.printStackTrace()

            // Fallback: Return a simple TextView with the code
            return TextView(context).apply {
                text = code
                typeface = Typeface.MONOSPACE
                setPadding(16, 16, 16, 16)
                setBackgroundColor(Color.parseColor("#f5f5f5"))
            }
        }
    }
    
    private class MessageDiffCallback : DiffUtil.ItemCallback<Message>() {
        override fun areItemsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem.id == newItem.id
        }
        override fun areContentsTheSame(oldItem: Message, newItem: Message): Boolean {
            return oldItem == newItem
        }
    }

    companion object {
        private const val VIEW_TYPE_USER = 0
        private const val VIEW_TYPE_BOT = 1
        private const val VIEW_TYPE_ERROR = 2
        private const val VIEW_TYPE_BOT_WITH_IMAGE = 3
    }
}