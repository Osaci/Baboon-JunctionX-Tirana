

package com.example.lilotest

import android.os.Bundle
import android.view.Menu
import android.view.MenuItem
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.ViewModelProvider
import com.example.lilotest.data.local.ChatHistoryManagerFactory
import com.example.lilotest.ui.chat.ChatFragment
import com.example.lilotest.ui.chat.ChatViewModel
import com.example.lilotest.ui.chat.ChatViewModelFactory
import com.example.lilotest.ui.theme.ThemeManager
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import android.util.Log
import java.io.File

class MainActivity : AppCompatActivity() {

    private lateinit var themeManager: ThemeManager
    private lateinit var viewModel: ChatViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Initialize theme manager
        themeManager = ThemeManager(this)

        // Apply current theme
        themeManager.applyTheme(this)
        
        // Initialize ViewModel with history support
        val factory = ChatViewModelFactory(applicationContext)
        viewModel = ViewModelProvider(this, factory)[ChatViewModel::class.java]
        
        // Log storage paths for debugging
        logStoragePaths()

        // Add chat fragment if this is the first creation
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .replace(R.id.container, ChatFragment())
                .commit()
        }
    }
    
    // Ensures theme is reapplied when re entering the main activity UI
    override fun onResume() {
        super.onResume()
        themeManager.applyTheme(this)
    }
    
    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.menu_chat, menu)
        return true
    }
    
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_clear_history -> {
                showClearHistoryConfirmation()
                true
            }
            R.id.action_backup_history -> {
                createBackup()
                true
            }
            R.id.action_view_stats -> {
                showHistoryStats()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
    
    private fun showClearHistoryConfirmation() {
        AlertDialog.Builder(this)
            .setTitle("Clear History")
            .setMessage("Are you sure you want to clear all chat history? This action cannot be undone.")
            .setPositiveButton("Clear") { _, _ ->
                viewModel.clearHistory()
                Toast.makeText(this, "Chat history cleared", Toast.LENGTH_SHORT).show()
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
    
    private fun createBackup() {
        viewModel.createBackup()
        Toast.makeText(this, "Backup created", Toast.LENGTH_SHORT).show()
    }
    
    private fun showHistoryStats() {
        val stats = viewModel.getHistoryStats()
        
        val threadCount = stats["threadCount"] as? Int ?: 0
        val messageCount = stats["messageCount"] as? Int ?: 0
        val fileSizeKB = stats["fileSizeKB"] as? Long ?: 0
        val lastModified = stats["lastModified"] as? Date
        
        val dateFormat = SimpleDateFormat("MMM dd, yyyy HH:mm", Locale.getDefault())
        val lastModifiedStr = lastModified?.let { dateFormat.format(it) } ?: "N/A"
        
        AlertDialog.Builder(this)
            .setTitle("Chat History Statistics")
            .setMessage("""
                Conversation threads: $threadCount
                Total messages: $messageCount
                History file size: $fileSizeKB KB
                Last saved: $lastModifiedStr
                
                Storage path: 
                ${stats["filePath"] ?: "Not saved yet"}
            """.trimIndent())
            .setPositiveButton("OK", null)
            .show()
    }
    
    private fun logStoragePaths() {
        val internalDir = filesDir.absolutePath
        Log.d("MainActivity", "Internal storage path: $internalDir")
        Log.d("MainActivity", "Chat history should be at: $internalDir/chat_history.json")
        
        // Check if history file exists
        val historyFile = File(filesDir, "chat_history.json")
        if (historyFile.exists()) {
            val fileSize = historyFile.length() / 1024 // KB
            Log.d("MainActivity", "Chat history file exists, size: $fileSize KB")
        } else {
            Log.d("MainActivity", "Chat history file does not exist yet")
        }
    }
}


ChatViewModel.kt
package com.example.lilotest.ui.chat

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lilotest.data.local.ChatHistoryManager
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageThread
import com.example.lilotest.data.model.MessageType
import com.example.lilotest.data.model.MessageVersion
import com.example.lilotest.data.remote.MessageRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.Date
import java.util.UUID
import android.util.Log

/**
 * ViewModel that handles chat functionality and manages message threads
 * with local storage support.
 */
class ChatViewModel(
    private val repository: MessageRepository = MessageRepository(),
    private val historyManager: ChatHistoryManager? = null
) : ViewModel() {

    private val TAG = "ChatViewModel"
    
    private val _messages = MutableLiveData<List<Message>>(emptyList())
    val messages: LiveData<List<Message>> = _messages
    
    // Loading state for UI
    private val _isLoading = MutableLiveData<Boolean>(false)
    val isLoading: LiveData<Boolean> = _isLoading

    // Store message threads for version history
    private val messageThreads = mutableMapOf<String, MessageThread>()

    // Track the active thread for navigation operations
    private var activeThreadId: String? = null
    
    // Flag to prevent auto-saving during initial loading
    private var isInitializing = true
    
    init {
        // Load saved history when ViewModel is created
        if (historyManager != null) {
            _isLoading.value = true
            loadSavedHistory()
        } else {
            isInitializing = false
            Log.d(TAG, "No history manager provided, history persistence disabled")
        }
    }
    
    /**
     * Loads chat history from local storage
     */
    private fun loadSavedHistory() {
        historyManager?.let { manager ->
            viewModelScope.launch(Dispatchers.IO) {
                try {
                    Log.d(TAG, "Loading chat history from local storage...")
                    val savedThreads = manager.loadHistory()
                    
                    withContext(Dispatchers.Main) {
                        if (savedThreads.isNotEmpty()) {
                            messageThreads.clear()
                            messageThreads.putAll(savedThreads)
                            
                            // Set active thread to the last one used
                            val lastThread = savedThreads.values.maxByOrNull { 
                                it.versions.maxOfOrNull { version -> version.timestamp.time } ?: 0L 
                            }
                            
                            lastThread?.let { thread ->
                                activeThreadId = thread.id
                                
                                // Set messages to the active chain
                                val chainId = thread.activeChainId
                                if (chainId != null) {
                                    val chainMessages = thread.chains[chainId]?.messages ?: emptyList()
                                    
                                    _messages.value = chainMessages.toList()
                                    Log.d(TAG, "Set UI to display thread ${thread.id}, chain $chainId with ${chainMessages.size} messages")
                                }
                            }
                            
                            Log.d(TAG, "Chat history loaded successfully with ${savedThreads.size} threads")
                        } else {
                            Log.d(TAG, "No saved chat history found or empty history")
                        }
                        
                        _isLoading.value = false
                        isInitializing = false
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error loading saved history", e)
                    withContext(Dispatchers.Main) {
                        _isLoading.value = false
                        isInitializing = false
                    }
                }
            }
        } ?: run {
            _isLoading.value = false
            isInitializing = false
        }
    }
    
    /**
     * Saves current chat history to local storage
     */
    private fun saveHistory() {
        if (isInitializing || historyManager == null) return
        if (messageThreads.isEmpty()) {
            Log.d(TAG, "No message threads to save")
            return
        }
        
        viewModelScope.launch(Dispatchers.IO) {
            try {
                Log.d(TAG, "Saving chat history with ${messageThreads.size} threads...")
                historyManager.saveHistory(messageThreads)
            } catch (e: Exception) {
                Log.e(TAG, "Error saving history", e)
            }
        }
    }
    
    /**
     * Creates an automatic backup of the current chat history
     */
    fun createBackup() {
        historyManager?.let { manager ->
            viewModelScope.launch(Dispatchers.IO) {
                try {
                    // Save latest changes first
                    manager.saveHistory(messageThreads)
                    // Then create a backup
                    manager.createBackup("manual")
                    Log.d(TAG, "Manual backup created successfully")
                } catch (e: Exception) {
                    Log.e(TAG, "Error creating backup", e)
                }
            }
        } ?: Log.d(TAG, "Cannot create backup: no history manager")
    }
    
    /**
     * Clears all chat history
     */
    fun clearHistory() {
        if (historyManager == null) {
            Log.d(TAG, "No history manager available, nothing to clear")
            return
        }
        
        _isLoading.value = true
        viewModelScope.launch(Dispatchers.IO) {
            try {
                Log.d(TAG, "Clearing all chat history...")
                historyManager.clearHistory()
                
                withContext(Dispatchers.Main) {
                    messageThreads.clear()
                    _messages.value = emptyList()
                    activeThreadId = null
                    
                    Log.d(TAG, "Chat history cleared successfully")
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error clearing history", e)
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                }
            }
        }
    }
    
    /**
     * Reloads message history from local storage
     * Useful after importing history
     */
    fun reloadHistory() {
        if (historyManager == null) {
            Log.d(TAG, "No history manager available, cannot reload")
            return
        }
        
        _isLoading.value = true
        isInitializing = true
        viewModelScope.launch(Dispatchers.IO) {
            try {
                Log.d(TAG, "Reloading chat history from storage...")
                val savedThreads = historyManager.loadHistory()
                
                withContext(Dispatchers.Main) {
                    // Clear current state
                    messageThreads.clear()
                    _messages.value = emptyList()
                    activeThreadId = null
                    
                    // Add loaded threads
                    messageThreads.putAll(savedThreads)
                    
                    // Set active thread to the last one used
                    val lastThread = savedThreads.values.maxByOrNull { 
                        it.versions.maxOfOrNull { version -> version.timestamp.time } ?: 0L 
                    }
                    
                    lastThread?.let { thread ->
                        activeThreadId = thread.id
                        
                        // Set messages to the active chain
                        val chainId = thread.activeChainId
                        if (chainId != null) {
                            val chainMessages = thread.chains[chainId]?.messages ?: emptyList()
                            _messages.value = chainMessages.toList()
                            Log.d(TAG, "UI updated with ${chainMessages.size} messages from thread ${thread.id}")
                        }
                    }
                    
                    Log.d(TAG, "Chat history reloaded with ${savedThreads.size} threads")
                    isInitializing = false
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error reloading saved history", e)
                withContext(Dispatchers.Main) {
                    isInitializing = false
                    _isLoading.value = false
                }
            }
        }
    }

    fun sendMessage(content: String) {
        val threadId = activeThreadId ?: UUID.randomUUID().toString()
        
        Log.d(TAG, "Sending message in thread: $threadId")
        if (activeThreadId == null) {
            Log.d(TAG, "Creating new thread with ID: $threadId")
        }

        // Create user message
        val userMessage = Message(
            id = System.currentTimeMillis().toString(),
            content = content,
            type = MessageType.USER,
            timestamp = Date(),
            threadId = threadId,
            versionNumber = 0
        )

        // Create thread to track versions
        val messageThread = messageThreads[threadId] ?: MessageThread(threadId).also {
            messageThreads[threadId] = it
            Log.d(TAG, "Created new MessageThread with ID: $threadId")
        }
        val currentMessages = _messages.value?.toMutableList() ?: mutableListOf()

        // If new message in existing chain
        if (activeThreadId != null) {
            // Add to the active chain
            val chainId = messageThread.activeChainId
            if (chainId != null) {
                val chainMessage = userMessage.copy(chainId = chainId)
                messageThread.addMessageToActiveChain(chainMessage)
                // Add message to the visible messages list
                currentMessages.add(chainMessage)
                _messages.value = currentMessages.toList()
                Log.d(TAG, "Added message to existing chain: $chainId")
            } else { 
                // Create a new chain if needed
                val newChainId = messageThread.createNewChain()
                val chainMessage = userMessage.copy(chainId = newChainId)

                messageThread.addMessageToActiveChain(chainMessage)
                // Add user message to the active/visible messages list
                currentMessages.add(chainMessage)
                _messages.value = currentMessages.toList()
                Log.d(TAG, "Created new chain $newChainId for message in thread $threadId")
            }
        } else {
            // This is a new thread
            messageThread.addVersion(userMessage)
            activeThreadId = threadId

            // Add user message to the visible messages list
            currentMessages.add(userMessage)
            _messages.value = currentMessages.toList()
            Log.d(TAG, "Started new thread $threadId with first message")
        }

        // Save history after updating with user message
        saveHistory()

        // Send message to the server
        viewModelScope.launch {
            try {
                Log.d(TAG, "Sending message to API: $content")
                
                // Get active chain messages for history context
                val activeChainId = messageThread.activeChainId
                val conversationHistory = if (activeChainId != null) {
                    // Get messages from active chain sorted by timestamp
                    messageThread.getActiveChainMessages()
                } else {
                    // If no active chain, just use the current user message
                    listOf(userMessage)
                }
                
                Log.d(TAG, "Including ${conversationHistory.size} previous messages as context")
                
                // Send the message with history context
                val response = repository.sendMessage(
                    message = content,
                    conversationHistory = conversationHistory,
                    activeChainId = activeChainId
                )
                
                Log.d(TAG, "Received response from API, length: ${response.length}")
          
                // Create bot response message
                val botResponse = createBotResponseMessage(response, threadId)

                // Get current active thread
                val thread = messageThreads[threadId]
                if (thread != null) {
                    if (thread.activeChainId != null) {
                        // Add to active chain
                        val chainBotResponse = botResponse.copy(chainId = thread.activeChainId)
                        thread.addMessageToActiveChain(chainBotResponse)
                        
                        // Add bot response to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(chainBotResponse)
                        _messages.value = updatedMessages
                        
                        Log.d(TAG, "Added bot response to chain ${thread.activeChainId}")
                        
                    } else {
                        // Update the current version with the bot response
                        thread.updateCurrentVersion(botResponse = botResponse, updateChain = false)
                        
                        // Add bot response to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(botResponse)
                        _messages.value = updatedMessages
                        
                        Log.d(TAG, "Updated version ${thread.currentVersionIndex} with bot response")
                    }
                    
                    // Log the updated chain structure for debugging
                    thread.logChainStructure()
                    
                    // Save history after receiving bot response
                    saveHistory()
                    
                    // Create automatic backup every 10 messages
                    val totalMessages = thread.chains.values.sumOf { it.messages.size }
                    if (totalMessages % 10 == 0 && historyManager != null) {
                        historyManager.createBackup()
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error sending message", e)
                
                // Handle error
                val errorMessage = Message(
                    id = System.currentTimeMillis().toString(),
                    content = "Error: ${e.message}",
                    type = MessageType.ERROR,
                    timestamp = Date(),
                    threadId = threadId
                )

                val thread = messageThreads[threadId]
                if (thread != null) {
                    if (thread.activeChainId != null) {
                        // Add to active chain
                        val chainErrorMsg = errorMessage.copy(chainId = thread.activeChainId)
                        thread.addMessageToActiveChain(chainErrorMsg)

                        // Add error to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(chainErrorMsg)
                        _messages.value = updatedMessages
                        
                        Log.e(TAG, "Added error message to chain ${thread.activeChainId}")
                    } else {
                        // Update the current version with the error response
                        thread.updateCurrentVersion(botResponse = errorMessage)

                        // Add error to visible messages
                        val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                        updatedMessages.add(errorMessage)
                        _messages.value = updatedMessages
                        
                        Log.e(TAG, "Updated version ${thread.currentVersionIndex} with error message")
                    }
                    
                    // Save history even after error
                    saveHistory()
                }
            }
        }
    }

    private fun createBotResponseMessage(responseText: String, threadId: String): Message {
        // Check for image url prefix
        if (responseText.contains("!IMAGEURL!")) {
            Log.d(TAG, "Response contains image URL")
            val parts = responseText.split("!IMAGEURL!")
            val contentText = parts[0].trim()
            val imageUrl = parts[1].trim()

            return Message(
                id = System.currentTimeMillis().toString(),
                content = contentText,
                type = MessageType.BOT,
                timestamp = Date(),
                containsImage = true,
                imageUrl = imageUrl,
                threadId = threadId
            )
        }
        // Check for image data prefix
        else if (responseText.contains("!IMAGEDATA!")) {
            Log.d(TAG, "Response contains image data")
            val parts = responseText.split("!IMAGEDATA!")
            val contentText = parts[0].trim()
            val imageData = parts[1].trim()

            return Message(
                id = System.currentTimeMillis().toString(),
                content = contentText,
                type = MessageType.BOT,
                timestamp = Date(),
                containsImage = true,
                imageData = imageData,
                threadId = threadId
            )
        }
        //Regular text response
        else {
            return Message(
                id = System.currentTimeMillis().toString(),
                content = responseText,
                type = MessageType.BOT,
                timestamp = Date(),
                threadId = threadId
            )
        }
    }

    fun logAllThreads() {
        Log.d(TAG, "====== THREAD SUMMARY ======")
        messageThreads.forEach { (threadId, thread) ->
            val isActive = if (threadId == activeThreadId) " (ACTIVE)" else ""
            Log.d(TAG, "Thread $threadId$isActive")
            Log.d(TAG, "├─ Versions: ${thread.versions.size}, Current: ${thread.currentVersionIndex}")
            Log.d(TAG, "├─ Chains: ${thread.chains.size}, Active: ${thread.activeChainId}")
            
            thread.logVersions(TAG)

            thread.chains.forEach { (chainId, chain) ->
                val isActiveChain = if (chainId == thread.activeChainId) " (ACTIVE)" else ""
                Log.d(TAG, "├─ Chain $chainId$isActiveChain")
                Log.d(TAG, "│  ├─ From version: ${chain.fromVersionIndex}")
                Log.d(TAG, "│  ├─ Messages: ${chain.messages.size}")
                Log.d(TAG, "│  └─ Created: ${chain.timestamp}")
            }
        }
        Log.d(TAG, "============================")
    }

    fun editMessage(messageId: String, newContent: String) {
        Log.d(TAG, "Starting edit for message $messageId")
        val currentMessages = _messages.value?.toMutableList() ?: return

        // Find the message to edit
        val messageIndex = currentMessages.indexOfFirst { it.id == messageId }
        if (messageIndex == -1) {
            Log.e(TAG, "Could not find message with ID: $messageId")
            return
        }

        val messageToEdit = currentMessages[messageIndex]
        val threadId = messageToEdit.threadId ?: return

        // Determine the lineade ID (use existing one or create a new from original message Id)
        var editLineageId = messageToEdit.editLineageId

        Log.d(TAG, "Editing message in thread $threadId, lineage ID: $editLineageId")
        
        if (editLineageId == null) {
            val thread = messageThreads[threadId]

            if (thread != null) {
                for (chain in thread.chains.values) {
                    for (msg in chain.messages) {
                        if (msg.id == messageId || msg.originalMessageId == messageId) {
                            // Found a match - use its lineage if available, or its ID as lineage
                            editLineageId = msg.editLineageId ?: msg.id
                            break
                        }
                    }
                    if (editLineageId != null) break
                }
            }
            // If no lineage found, use messages own Id
            editLineageId = editLineageId ?: messageId
        }
        Log.d(TAG, "Using lineage ID: $editLineageId")

        // Track active thread for navigation
        activeThreadId = threadId

        // Get the thread or create one if it doesn't exist
        val thread = messageThreads[threadId] ?: run {
            Log.d(TAG, "Creating new thread for $threadId")
            val newThread = MessageThread(threadId)
            messageThreads[threadId] = newThread
            newThread
        }

        Log.d(TAG, "Current thread state: versions=${thread.versions.size}, currentIndex=${thread.currentVersionIndex}")

        // Create a new message version
        val editedUserMessage = Message(
            id = System.currentTimeMillis().toString(),
            content = newContent,
            type = MessageType.USER,
            timestamp = Date(),
            threadId = threadId,
            hasVersionHistory = true,
            versionNumber = thread.versions.size,
            originalMessageId = messageId,
            editLineageId = editLineageId ?: messageId
        )

        // Add the new version to the thread
        val newVersionIndex = thread.addVersion(editedUserMessage)
        Log.d(TAG, "Added version at index $newVersionIndex. Total versions: ${thread.versions.size}")

        markAllThreadVersionsWithHistory(threadId)

        // Create new chain for edited version
        val newChainId = thread.createNewChain()
        Log.d(TAG, "Created new chain $newChainId for edited message")

        // Find previous chain to copy messages from
        val previousChainId = thread.chains.keys
            .filter { it != newChainId }
            .maxByOrNull { thread.chains[it]?.timestamp ?: Date(0) }

        val messagesToInclude = mutableListOf<Message>()
        val previousChain = previousChainId?.let { thread.chains[it] }
 
        if (previousChain != null) {
            Log.d(TAG, "Previous chain found: $previousChainId with ${previousChain.messages.size} messages")
        
            // Find the index of the message being edited in the previous chain
            val originalMessageIndex = previousChain.messages.indexOfFirst { 
                it.id == messageId || (it.type == MessageType.USER && it.content == messageToEdit.content)
            }
        
            if (originalMessageIndex >= 0) {
                Log.d(TAG, "Found original message at position $originalMessageIndex in previous chain")
            
                // Clear the data structures we'll use to track messages
                val orderedMessages = mutableMapOf<Int, Message>()
                thread.chains[newChainId]?.messages?.clear()
            
                // Copy messages BEFORE the edited message with their original positions
                for (i in 0 until originalMessageIndex) {
                    val originalMsg = previousChain.messages[i]
                    val msg = originalMsg.copy(
                        chainId = newChainId,
                        editLineageId = originalMsg.editLineageId ?: originalMsg.id, // Keep lineage
                        originalMessageId = originalMsg.originalMessageId ?: originalMsg.id // Keep original message Id
                    )
                    orderedMessages[i] = msg
                    thread.addMessageToActiveChain(msg)
                    Log.d(TAG, "Copied previous message to new chain: ${msg.content?.take(20)}...")
                }
            
                // Add the edited message at the ORIGINAL position (replacing the old one)
                val chainMessage = editedUserMessage.copy(chainId = newChainId)
                orderedMessages[originalMessageIndex] = chainMessage
                thread.addMessageToActiveChain(chainMessage)
                Log.d(TAG, "Added edited message at position $originalMessageIndex")
            
                // Add messages to the visible list in correct order
                messagesToInclude.addAll(orderedMessages.toSortedMap().values)
                Log.d(TAG, "Final message list has ${messagesToInclude.size} messages")
            } else {
                // If we can't find the original message, just add the edited message
                val chainMessage = editedUserMessage.copy(chainId = newChainId)
                messagesToInclude.add(chainMessage)
                thread.addMessageToActiveChain(chainMessage)
                Log.d(TAG, "Could not find original message in previous chain, adding only edited message")
            }
        } else {
            // No previous chain, just add the edited message
            Log.d(TAG, "No previous chain found")
            val chainMessage = editedUserMessage.copy(chainId = newChainId)
            messagesToInclude.add(chainMessage)
            thread.addMessageToActiveChain(chainMessage)
        }
    
        Log.d(TAG, "== EDIT LINEAGE SUMMARY ==")
        thread.chains.forEach { (chainId, chain) ->
            chain.messages.forEach { msg ->
                if (msg.type == MessageType.USER && (msg.editLineageId != null || msg.originalMessageId != null)) {
                    Log.d(TAG, "Chain ${chainId.take(8)}: Message ${msg.id.take(8)}, content=${msg.content?.take(20)}, " +
                            "originalId=${msg.originalMessageId?.take(8) ?: "none"}, " +
                            "lineageId=${msg.editLineageId?.take(8) ?: "none"}")
                }
            }
        }              
        // Update the UI with preserved messages plus edited message
        _messages.value = messagesToInclude
        
        // Save history after edit
        saveHistory()

        // Fetch a new response for the edited message
        viewModelScope.launch {
            try {
                Log.d(TAG, "Sending edited message to API: $newContent")
                
                // Get the conversation history for this new chain
                val conversationHistory = thread.getActiveChainMessages()
                Log.d(TAG, "Including ${conversationHistory.size} messages as context for edited message")
                
                // Send message with conversation history context
                val response = repository.sendMessage(
                    message = newContent,
                    conversationHistory = conversationHistory,
                    activeChainId = newChainId
                )
                
                Log.d(TAG, "Received response for edited message, length: ${response.length}")

                // Create the new bot response
                val newBotResponse = createBotResponseMessage(response, threadId).copy(
                    versionNumber = newVersionIndex,
                    hasVersionHistory = true,
                    chainId = newChainId
                )

                // Update the thread with the new bot response
                thread.updateCurrentVersion(botResponse = newBotResponse, updateChain = false)
                thread.addMessageToActiveChain(newBotResponse)

                // Add the new bot response to visible messages
                val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                updatedMessages.add(newBotResponse)
                _messages.value = updatedMessages
                
                Log.d(TAG, "Added bot response to edited message chain")
                
                // Log chain table and structure
                MessageTableLogger.logMessageChainsAsTable(thread)
                thread.logChainStructure()
                
                // Save history after receiving bot response
                saveHistory()

            } catch (e: Exception) {
                Log.e(TAG, "Error sending edited message", e)

                // Handle error
                val errorMessage = Message(
                    id = System.currentTimeMillis().toString(),
                    content = "Error: ${e.message}",
                    type = MessageType.ERROR,
                    timestamp = Date(),
                    threadId = threadId,
                    versionNumber = newVersionIndex,
                    hasVersionHistory = true,
                    chainId = newChainId
                )

                // Update the thread with the error response
                thread.updateCurrentVersion(botResponse = errorMessage, updateChain = false)
                thread.addMessageToActiveChain(errorMessage)

                // Add error to visible messages
                val updatedMessages = _messages.value?.toMutableList() ?: mutableListOf()
                updatedMessages.add(errorMessage)
                _messages.value = updatedMessages
                MessageTableLogger.logMessageChainsAsTable(thread)
                
                // Save history even after error
                saveHistory()
            }
        }
    }

    /**
     * Navigate to specific version of a message thread
     */
    fun navigateToSpecificVersion(threadId: String, targetVersionIndex: Int): Boolean {
        Log.d(TAG, "Navigating to version $targetVersionIndex in thread $threadId")
        val thread = messageThreads[threadId] ?: return false

        // Validate target index
        if (targetVersionIndex < 0 || targetVersionIndex >= thread.versions.size) {
            Log.e(TAG, "Invalid version index: $targetVersionIndex (valid range: 0-${thread.versions.size - 1})")
            return false
        }

        // Set the current version index directly
        thread.currentVersionIndex = targetVersionIndex

        // Find or create a chain for this version
        val chainsForVersion = thread.getChainsForVersion(targetVersionIndex)
        val chainId = if (chainsForVersion.isNotEmpty()) {
            chainsForVersion.maxByOrNull { it.timestamp }?.chainId
        } else {
            thread.createNewChain()
        }

        // Switch to this chain
        if (chainId != null) {
            // Get messages from this chain
            val chainMessages = thread.chains[chainId]?.messages ?: emptyList()
            // Replace current messages from the messages in this chain
            _messages.value = ArrayList(chainMessages)

            Log.d(TAG, "Switched to chain $chainId with ${chainMessages.size} messages")
            
            // Log chain table and structure
            MessageTableLogger.logMessageChainsAsTable(thread)
            thread.logChainStructure()
            
            // Save history after navigation
            saveHistory()
            
            return true
        }
        return false
    }
    
    /**
     * Navigate to the previous version of a message thread
     */
    fun navigateToPreviousVersion(threadId: String): Boolean {
        Log.d(TAG, "Navigating to previous version in thread $threadId")
        val thread = messageThreads[threadId] ?: run {
            Log.e(TAG, "Thread not found: $threadId")
            return false
        }

        if (!thread.hasPreviousVersion()) {
            Log.d(TAG, "No previous version available - already at version ${thread.currentVersionIndex}")
            return false
        }

        val prevIndex = thread.currentVersionIndex - 1
        Log.d(TAG, "Moving from version ${thread.currentVersionIndex} to $prevIndex")
        
        val previousVersion = thread.moveToPreviousVersion() ?: return false

        // Get the chain related to this thread
        val chainId = thread.activeChainId ?: return false

        val result = handleChainNavigation(chainId)
        
        // Save history after navigation if successful
        if (result) {
            saveHistory()
        }
        
        return result
    }

    /**
     * Navigate to the next version of a message thread
     */
    fun navigateToNextVersion(threadId: String): Boolean {
        Log.d(TAG, "Navigating to next version in thread $threadId")
        val thread = messageThreads[threadId] ?: run {
            Log.e(TAG, "Thread not found: $threadId")
            return false
        }

        if (!thread.hasNextVersion()) {
            Log.d(TAG, "No next version available - already at latest version ${thread.currentVersionIndex}")
            return false
        }
 
        val nextIndex = thread.currentVersionIndex + 1
        Log.d(TAG, "Moving from version ${thread.currentVersionIndex} to $nextIndex")
        
        val nextVersion = thread.moveToNextVersion() ?: return false
        // Get the chain related to this version
        val chainId = thread.activeChainId ?: return false

        val result = handleChainNavigation(chainId)
        
        // Save history after navigation if successful
        if (result) {
            saveHistory()
        }
        
        return result
    }

    private fun markAllThreadVersionsWithHistory(threadId: String) {
        val thread = messageThreads[threadId] ?: return
    
        // Only mark with history if there's more than one version
        if (thread.versions.size <= 1) return
    
        Log.d(TAG, "Marking all ${thread.versions.size} versions in thread $threadId with hasVersionHistory")
    
        // Update all versions with hasVersionHistory flag
        for (i in thread.versions.indices) {
            val version = thread.versions[i]
        
            // Update user message
            val updatedUserMessage = version.userMessage.copy(hasVersionHistory = true)
        
            // Update bot response if it exists
            val updatedBotResponse = version.botResponse?.copy(hasVersionHistory = true)
        
            // Replace the version
            thread.versions[i] = MessageVersion(updatedUserMessage, updatedBotResponse, version.timestamp)
        }
    }

    private fun validateChain(chainId: String) {
        val threadId = activeThreadId ?: return
        val thread = messageThreads[threadId] ?: return
        val chain = thread.chains[chainId] ?: return

        // Remove duplicate bot responses
        val uniqueMessages = mutableListOf<Message>()
        val seenBotResponses = mutableSetOf<String>()
        
        chain.messages.forEach { message ->
            if (message.type == MessageType.BOT) {
                val content = message.content ?: ""
                if (!seenBotResponses.contains(content)) {
                    seenBotResponses.add(content)
                    uniqueMessages.add(message)
                } else {
                    Log.d(TAG, "Removed duplicate bot response: ${content.take(20)}...")
                }
            } else {
                uniqueMessages.add(message)
            }
        }
        // Only replace if we removed messages
        if (uniqueMessages.size < chain.messages.size) {
            Log.d(TAG, "Chain validation removed ${chain.messages.size - uniqueMessages.size} duplicate messages")
            chain.messages.clear()
            chain.messages.addAll(uniqueMessages)
        }
    }

    /**
     * Ensures chain navigation updates UI correctly
     */
    private fun handleChainNavigation(chainId: String): Boolean {
        val threadId = activeThreadId ?: return false
        val thread = messageThreads[threadId] ?: return false
        val chain = thread.chains[chainId] ?: return false
    
        // Set the active chain
        thread.activeChainId = chainId
    
        // Get messages from this chain
        val chainMessages = chain.messages.toList()
    
        // Important: Create a new list to break reference to old list state
        _messages.value = ArrayList(chainMessages)
    
        // Log the chain switch
        Log.d(TAG, "Switched to chain $chainId with ${chainMessages.size} messages")
    
        // Log chain structure after navigation
        thread.logChainStructure()
        return true
    }

    /**
     * Updates visible messages to display the specified version's chain
     */
    fun switchToChain(threadId: String, chainId: String): Boolean { 
        val thread = messageThreads[threadId] ?: return false

        // Activate the requested chain
        val chainMessages = thread.activateChain(chainId) ?: return false

        // Update the UI with the messages from this chain
        _messages.value = chainMessages

        Log.d(TAG, "Switched to chain $chainId with ${chainMessages.size} messages")
        
        // Log chain structure after navigation
        thread.logChainStructure()
        
        // Save history after switching chains
        saveHistory()

        return true
    }

    fun getMessageThread(threadId: String): MessageThread? {
        return messageThreads[threadId]
    }

    fun getMessageThreads(): Map<String, MessageThread> {
        return messageThreads
    }
    
    /**
     * Get chat history statistics for display
     */
    fun getHistoryStats(): Map<String, Any> {
        val stats = mutableMapOf<String, Any>()
        
        stats["threadCount"] = messageThreads.size
        
        val chainCount = messageThreads.values.sumOf { it.chains.size }
        stats["chainCount"] = chainCount
        
        val messageCount = messageThreads.values.sumOf { thread ->
            thread.chains.values.sumOf { chain -> chain.messages.size }
        }
        stats["messageCount"] = messageCount
        
        val versionCount = messageThreads.values.sumOf { it.versions.size }
        stats["versionCount"] = versionCount
        
        // Get the path to the history file
        historyManager?.let { manager ->
            val historyFile = File(context.filesDir, "chat_history.json")
            if (historyFile.exists()) {
                stats["fileSizeKB"] = historyFile.length() / 1024
                stats["lastModified"] = Date(historyFile.lastModified())
                stats["filePath"] = historyFile.absolutePath
            }
        }
        
        return stats
    }
    
    override fun onCleared() {
        super.onCleared()
        // Save history one last time when ViewModel is destroyed
        saveHistory()
        // Create backup before exit
        if (!isInitializing && historyManager != null) {
            viewModelScope.launch(Dispatchers.IO) {
                historyManager.createBackup("exit")
            }
        }
    }
}



ChatFragment.kt

package com.example.lilotest.ui.chat

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import com.google.android.material.textfield.TextInputEditText

/**
 * Fragment that handles the chat interface
 */
class ChatFragment : Fragment() {

    private val TAG = "ChatFragment"
    
    // Views
    private lateinit var recyclerView: RecyclerView
    private lateinit var messageInput: TextInputEditText
    private lateinit var sendButton: ImageButton
    private lateinit var progressBar: ProgressBar
    private lateinit var emptyStateText: TextView
    
    // Adapter
    private lateinit var messageAdapter: MessageAdapter
    
    // ViewModel - shared with the activity
    private lateinit var viewModel: ChatViewModel
    
    override fun onCreateView(
        inflater: LayoutInflater, 
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_chat, container, false)
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Initialize views
        initViews(view)
        
        // Get ViewModel from activity to ensure it's shared
        viewModel = ViewModelProvider(requireActivity())[ChatViewModel::class.java]
        
        // Initialize adapter
        setupAdapter()
        
        // Observe messages from ViewModel
        observeViewModel()
        
        // Set up listeners
        setupListeners()
    }
    
    private fun initViews(view: View) {
        recyclerView = view.findViewById(R.id.messages_recycler_view)
        messageInput = view.findViewById(R.id.message_input)
        sendButton = view.findViewById(R.id.send_button)
        progressBar = view.findViewById(R.id.progress_bar)
        emptyStateText = view.findViewById(R.id.empty_state_text)
        
        // Configure RecyclerView
        recyclerView.layoutManager = LinearLayoutManager(requireContext()).apply {
            stackFromEnd = true // Messages should stack from bottom
        }
    }
    
    private fun setupAdapter() {
        
        // Create instance of the factory
        val viewHolderFactory = MessageViewHolderFactory()

        // Create adapter with the factory
        messageAdapter = MessageAdapter(viewHolderFactory)
    
        // Set the view model for the adapter
        messageAdapter.setChatViewModel(viewModel)

        // Set edit message listener
        messageAdapter.setEditMessageListener(object : MessageAdapter.EditMessageListener {
            override fun onMessageEdited(messageId: String, newContent: String) {
                viewModel.editMessage(messageId, newContent)
            }
        })


        // Set up version navigation listener
        messageAdapter.setVersionNavigationListener(object : MessageAdapter.MessageVersionNavigationListener {
            override fun onPreviousVersion(threadId: String) {
                viewModel.navigateToPreviousVersion(threadId)
            }
        
            override fun onNextVersion(threadId: String) {
                viewModel.navigateToNextVersion(threadId)
            }
        
            override fun navigateToSpecificVersion(threadId: String, versionIndex: Int) {
                viewModel.navigateToSpecificVersion(threadId, versionIndex)
            }
        })
        recyclerView.adapter = messageAdapter
    }

    private fun observeViewModel() {
        // Observe messages
        viewModel.messages.observe(viewLifecycleOwner) { messages ->
            if (messages.isEmpty()) {
                showEmptyState(true)
            } else {
                showEmptyState(false)
                messageAdapter.submitList(messages)
                // Scroll to bottom after a short delay to ensure adapter has updated
                recyclerView.postDelayed({
                    recyclerView.scrollToPosition(messages.size - 1)
                }, 100)
            }
        }
        
        // Observe loading state
        viewModel.isLoading.observe(viewLifecycleOwner) { isLoading ->
            progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
            
            // Disable send button during loading
            sendButton.isEnabled = !isLoading
            messageInput.isEnabled = !isLoading
        }
    }
    
    private fun setupListeners() {
        // Send button click
        sendButton.setOnClickListener {
            val message = messageInput.text.toString().trim()
            if (message.isNotEmpty()) {
                sendMessage(message)
                messageInput.text?.clear()
            }
        }
        
        // Enter key press in input field
        messageInput.setOnEditorActionListener { _, actionId, _ ->
            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {
                val message = messageInput.text.toString().trim()
                if (message.isNotEmpty()) {
                    sendMessage(message)
                    messageInput.text?.clear()
                }
                true
            } else {
                false
            }
        }
    }
    
    private fun sendMessage(content: String) {
        viewModel.sendMessage(content)
    }
    
    private fun showEditDialog(message: Message) {
        if (message.type != MessageType.USER) return
        
        val editText = TextInputEditText(requireContext()).apply {
            setText(message.content)
            setSelection(message.content?.length ?: 0)
        }
        
        AlertDialog.Builder(requireContext())
            .setTitle("Edit Message")
            .setView(editText)
            .setPositiveButton("Save") { _, _ ->
                val newContent = editText.text.toString().trim()
                if (newContent.isNotEmpty() && newContent != message.content) {
                    viewModel.editMessage(message.id, newContent)
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
    
    private fun copyToClipboard(content: String) {
        val clipboard = requireContext().getSystemService(android.content.Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager
        val clip = android.content.ClipData.newPlainText("Message", content)
        clipboard.setPrimaryClip(clip)
        Toast.makeText(requireContext(), "Copied to clipboard", Toast.LENGTH_SHORT).show()
    }
    
    private fun showEmptyState(show: Boolean) {
        if (show) {
            emptyStateText.visibility = View.VISIBLE
            recyclerView.visibility = View.GONE
        } else {
            emptyStateText.visibility = View.GONE
            recyclerView.visibility = View.VISIBLE
        }
    }
}


MessageAdapter.kt
package com.example.lilotest.ui.chat

import android.app.AlertDialog
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.ContextWrapper
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.GradientDrawable
import android.graphics.Typeface
import android.os.Handler
import android.os.Looper
import android.text.SpannableString
import android.text.Spanned
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.RelativeSizeSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.util.Base64
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.Button
import android.widget.EditText
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.graphics.ColorUtils
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageThread
import com.example.lilotest.data.model.MessageType
import com.example.lilotest.data.model.MessageChain
import com.example.lilotest.ui.theme.ThemeManager
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import java.util.regex.Pattern

class MessageAdapter( 
    private val viewHolderFactory: MessageViewHolderFactory
) : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {

    @Deprecated("Use the constructor with a MessageViewHolderFactory parameter")
    constructor() : this(throw IllegalStateException("MessageAdapter requires a viewHolderFactory"))
    private var chatViewModel: ChatViewModel? = null
    private val TAG = "MessageAdapter"
    private val THEME_TAG = "ThemeDebug"
    private var themeManager: ThemeManager? = null

    private var versionNavigationListener: MessageVersionNavigationListener? = null

    fun setChatViewModel(viewModel: ChatViewModel) {
        this.chatViewModel = viewModel
    }

    fun setVersionNavigationListener(listener: MessageVersionNavigationListener) {
        this.versionNavigationListener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {

        // Initialize theme manager if not already done
        if (themeManager == null) {
            themeManager = ThemeManager(parent.context)
        }
        
        // Use the factory to create the ViewHolder
        return viewHolderFactory.create(parent, viewType)
    }

    interface MessageVersionNavigationListener {
        fun onPreviousVersion(threadId: String)
        fun onNextVersion(threadId: String)
        fun navigateToSpecificVersion(threadId: String, versionIndex: Int)
    }

    interface OnMessageActionListener {
        fun onEditMessage(message: Message)
        fun onCopyContent(content: String)
    }

    interface VersionNavigationListener {
        fun navigateToNextVersion(threadId: String): Boolean
        fun navigateToPreviousVersion(threadId: String): Boolean
        fun navigateToSpecificVersion(threadId: String, versionIndex: Int): Boolean
    }

    interface EditMessageListener {
        fun onMessageEdited(messageId: String, newContent: String)
    }

    private var editMessageListener: EditMessageListener? = null

    fun setEditMessageListener(listener: EditMessageListener) {
        this.editMessageListener = listener
    }

    /**
     * Helper function to determine if two messages share a common ancestor
     */
    private fun findCommonAncestor(message: Message, ancestorId: String, allChains: Collection<MessageChain>): Boolean {
        var currentMsg = message
        val visited = mutableSetOf<String>()
        
        while (currentMsg.originalMessageId != null && !visited.contains(currentMsg.id)) {
            visited.add(currentMsg.id)
            
            if (currentMsg.originalMessageId == ancestorId) {
                return true
            }
            
            // Find the message with this ID in any chain
            var found = false
            for (chain in allChains) {
                val ancestor = chain.messages.find { it.id == currentMsg.originalMessageId }
                if (ancestor != null) {
                    currentMsg = ancestor
                    found = true
                    break
                }
            }
            if (!found) break
        }
        
        return false
    }

    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)

        try {
            // Initialize theme manager if not already done
            if (themeManager == null) {
                themeManager = ThemeManager(holder.itemView.context)
            }
            
            // Use the factory to update the ViewHolder styling
            val viewType = getItemViewType(position)
            viewHolderFactory.updateStyle(holder, viewType)

            // Get the message content safely
            val content = message.content ?: ""

            Log.d(TAG, "Processing message ID ${message.id}, content length: ${content.length}")

            // Check for code blocks or tables
            val hasSpecialBlocks = content.contains("```") || containsMarkdownTable(content)

            if (hasSpecialBlocks) {
                // Process content with special blocks
                processMessageWithSpecialBlocks(content, holder, message)
            } else {
                // Use text response for other parts
                val formattedText = formatTextWithoutCodeBlocks(content, holder.itemView.context)

                // Make sure regular text view has content
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = formattedText
                }

                // Set timestamp
                holder.setTimestamp(message.timestamp)
            }

            if (viewType == MessageViewHolderFactory.VIEW_TYPE_USER) {
                val threadId = message.threadId

                val editButton = holder.itemView.findViewById<ImageButton>(R.id.edit_message_button)
                val nextButton = holder.itemView.findViewById<ImageButton>(R.id.next_version_button)
                val prevButton = holder.itemView.findViewById<ImageButton>(R.id.prev_version_button)
                val versionCounterView = holder.itemView.findViewById<TextView>(R.id.version_counter)

                // Get the user message text color from ThemeManager
                val userMessageTextColor = themeManager?.getThemeColor(ThemeManager.ThemeColorType.USER_MESSAGE_TEXT) 
                    ?: ContextCompat.getColor(holder.itemView.context, R.color.light_user_msg_text)
                
                // Set the button colors to match the user message text color
                prevButton?.setColorFilter(userMessageTextColor)
                nextButton?.setColorFilter(userMessageTextColor)
                editButton?.setColorFilter(userMessageTextColor)
                versionCounterView?.setTextColor(userMessageTextColor)

                // Set click listener to show edit dialog
                editButton.setOnClickListener {
                    if (threadId != null) {
                        showEditMessageDialog(holder.itemView.context, message)
                    }
                }

                // Default state - hide navigation buttons
                prevButton?.visibility = View.GONE
                nextButton?.visibility = View.GONE
                versionCounterView?.visibility = View.GONE

                if (threadId != null) {
                    val thread = getMessageThreadInfo(threadId) ?: return
                    
                    // In onBindViewHolder, replace the version checking logic with this:

                    if (threadId != null && thread.versions.size > 1) {
                        // Get current version of the thread
                        val currentVersion = thread.currentVersionIndex
                            
                        // Get the lineage ID of this message
                        val messageLineageId = message.editLineageId ?: message.id
                            
                        Log.d(TAG, "Message at position $position: id=${message.id}, lineageId=$messageLineageId")
                            
                        // Find all versions that contain this message's lineage
                        val relatedVersions = mutableListOf<Int>()
                        val seenMessages = mutableSetOf<String>()
                            
                        // Check ALL versions and chains for related messages
                        for ((versionIndex, version) in thread.versions.withIndex()) {
                            // Check all chains that originate from this version
                            val chainsForVersion = thread.chains.values.filter { it.fromVersionIndex == versionIndex }
                                
                            for (chain in chainsForVersion) {
                                for (chainMsg in chain.messages) {
                                    if (chainMsg.type == message.type && 
                                        (chainMsg.editLineageId == messageLineageId || 
                                         chainMsg.id == messageLineageId ||
                                         chainMsg.originalMessageId == message.id ||
                                         message.originalMessageId == chainMsg.id)) {
                                            
                                        if (!seenMessages.contains(chainMsg.id)) {
                                            seenMessages.add(chainMsg.id)
                                            Log.d(TAG, "Found related message in version $versionIndex: id=${chainMsg.id}, content=${chainMsg.content?.take(20)}")
                                                
                                            if (!relatedVersions.contains(versionIndex)) {
                                                relatedVersions.add(versionIndex)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                            
                        Log.d(TAG, "Related version indices for message ${message.id}: $relatedVersions")
                            
                        // Only show version counter if this message has multiple versions
                        if (relatedVersions.size > 1) {
                            // Sort indices for consistent navigation
                            relatedVersions.sort()
                                
                            // Find which version we're currently viewing
                            val currentVersionPos = relatedVersions.indexOf(currentVersion)
                                
                            if (currentVersionPos >= 0) {
                                Log.d(TAG, "Setting counter to ${currentVersionPos + 1}/${relatedVersions.size}")
                                    
                                // Show navigation controls
                                prevButton?.visibility = View.VISIBLE
                                nextButton?.visibility = View.VISIBLE
                                versionCounterView?.visibility = View.VISIBLE
                                    
                                // Set version counter text
                                versionCounterView?.text = "${currentVersionPos + 1}/${relatedVersions.size}"
                                    
                                // Enable/disable navigation buttons
                                prevButton?.isEnabled = currentVersionPos > 0
                                prevButton?.alpha = if (currentVersionPos > 0) 1.0f else 0.5f
                                    
                                nextButton?.isEnabled = currentVersionPos < relatedVersions.size - 1
                                nextButton?.alpha = if (currentVersionPos < relatedVersions.size - 1) 1.0f else 0.5f
                                    
                                // Set click listeners
                                prevButton?.setOnClickListener {
                                    if (currentVersionPos > 0) {
                                        val prevVersionIdx = relatedVersions[currentVersionPos - 1]
                                        versionNavigationListener?.navigateToSpecificVersion(threadId, prevVersionIdx)
                                    }
                                }
                                    
                                nextButton?.setOnClickListener {
                                    if (currentVersionPos < relatedVersions.size - 1) {
                                        val nextVersionIdx = relatedVersions[currentVersionPos + 1]
                                        versionNavigationListener?.navigateToSpecificVersion(threadId, nextVersionIdx)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                // Hide navigation buttons for non-user messages
                val prevButton = holder.itemView.findViewById<ImageButton>(R.id.prev_version_button)
                val nextButton = holder.itemView.findViewById<ImageButton>(R.id.next_version_button)
                val versionCounterView = holder.itemView.findViewById<TextView>(R.id.version_counter)                

                prevButton?.visibility = View.GONE
                nextButton?.visibility = View.GONE
                versionCounterView?.visibility = View.GONE
            }

            // Process images
            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE

                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Loading from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(RequestOptions()
                                .diskCacheStrategy(DiskCacheStrategy.ALL)
                                .error(R.drawable.ic_error_placeholder))
                            .into(imageView)
                            .clearOnDetach()

                        progressBar.visibility = View.GONE

                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base 64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image data
                                val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try decoding directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            }
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()

            // Fallback to text binding
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = message.content ?: ""
            }
            holder.setTimestamp(message.timestamp)
        }
    }





fragment_chat.xml

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/messages_recycler_view"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toTopOf="@+id/input_layout"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <LinearLayout
        android:id="@+id/input_layout"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent">

        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1">
            
            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/message_input"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Type a message"
                android:imeOptions="actionSend"
                android:inputType="textCapSentences|textMultiLine"
                android:maxLines="4" />

        </com.google.android.material.textfield.TextInputLayout>

        <ImageButton
            android:id="@+id/send_button"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:layout_gravity="bottom"
            android:contentDescription="Send"
            android:src="@android:drawable/ic_menu_send" />

    </LinearLayout>
</androidx.constraintlayout.widget.ConstraintLayout>

ChatFragment.kt

package com.example.lilotest.ui.chat

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageType
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.textfield.TextInputEditText

/**
 * Fragment that handles the chat interface
 */
class ChatFragment : Fragment() {

    private val TAG = "ChatFragment"
    
    // Views
    private lateinit var recyclerView: RecyclerView
    private lateinit var messageInput: TextInputEditText
    private lateinit var sendButton: FloatingActionButton
    private lateinit var progressBar: ProgressBar
    private lateinit var emptyStateText: TextView
    
    // Adapter
    private lateinit var messageAdapter: MessageAdapter
    
    // ViewModel - shared with the activity
    private lateinit var viewModel: ChatViewModel
    
    override fun onCreateView(
        inflater: LayoutInflater, 
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_chat, container, false)
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Initialize views
        initViews(view)
        
        // Get ViewModel from activity to ensure it's shared
        viewModel = ViewModelProvider(requireActivity())[ChatViewModel::class.java]
        
        // Initialize adapter
        setupAdapter()
        
        // Observe messages from ViewModel
        observeViewModel()
        
        // Set up listeners
        setupListeners()
    }
    
    private fun initViews(view: View) {
        recyclerView = view.findViewById(R.id.messages_recycler_view)
        messageInput = view.findViewById(R.id.message_input)
        sendButton = view.findViewById(R.id.send_button)
        progressBar = view.findViewById(R.id.progress_bar)
        emptyStateText = view.findViewById(R.id.empty_state_text)
        
        // Configure RecyclerView
        recyclerView.layoutManager = LinearLayoutManager(requireContext()).apply {
            stackFromEnd = true // Messages should stack from bottom
        }
    }
    
    private fun setupAdapter() {
        messageAdapter = MessageAdapter(object : MessageAdapter.OnMessageActionListener {
            override fun onEditMessage(message: Message) {
                showEditDialog(message)
            }
            
            override fun onCopyContent(content: String) {
                copyToClipboard(content)
            }
        })
        
        recyclerView.adapter = messageAdapter
        
        // Set up version navigation listener
        messageAdapter.setVersionNavigationListener(object : MessageAdapter.VersionNavigationListener {
            override fun navigateToNextVersion(threadId: String): Boolean {
                return viewModel.navigateToNextVersion(threadId)
            }
            
            override fun navigateToPreviousVersion(threadId: String): Boolean {
                return viewModel.navigateToPreviousVersion(threadId)
            }
            
            override fun navigateToSpecificVersion(threadId: String, versionIndex: Int): Boolean {
                return viewModel.navigateToSpecificVersion(threadId, versionIndex)
            }
        })
    }
    
    private fun observeViewModel() {
        // Observe messages
        viewModel.messages.observe(viewLifecycleOwner) { messages ->
            if (messages.isEmpty()) {
                showEmptyState(true)
            } else {
                showEmptyState(false)
                messageAdapter.submitList(messages)
                // Scroll to bottom after a short delay to ensure adapter has updated
                recyclerView.postDelayed({
                    recyclerView.scrollToPosition(messages.size - 1)
                }, 100)
            }
        }
        
        // Observe loading state
        viewModel.isLoading.observe(viewLifecycleOwner) { isLoading ->
            progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
            
            // Disable send button during loading
            sendButton.isEnabled = !isLoading
            messageInput.isEnabled = !isLoading
        }
    }
    
    private fun setupListeners() {
        // Send button click
        sendButton.setOnClickListener {
            val message = messageInput.text.toString().trim()
            if (message.isNotEmpty()) {
                sendMessage(message)
                messageInput.text?.clear()
            }
        }
        
        // Enter key press in input field
        messageInput.setOnEditorActionListener { _, actionId, _ ->
            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {
                val message = messageInput.text.toString().trim()
                if (message.isNotEmpty()) {
                    sendMessage(message)
                    messageInput.text?.clear()
                }
                true
            } else {
                false
            }
        }
    }
    
    private fun sendMessage(content: String) {
        viewModel.sendMessage(content)
    }
    
    private fun showEditDialog(message: Message) {
        if (message.type != MessageType.USER) return
        
        val editText = TextInputEditText(requireContext()).apply {
            setText(message.content)
            setSelection(message.content?.length ?: 0)
        }
        
        AlertDialog.Builder(requireContext())
            .setTitle("Edit Message")
            .setView(editText)
            .setPositiveButton("Save") { _, _ ->
                val newContent = editText.text.toString().trim()
                if (newContent.isNotEmpty() && newContent != message.content) {
                    viewModel.editMessage(message.id, newContent)
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
    
    private fun copyToClipboard(content: String) {
        val clipboard = requireContext().getSystemService(android.content.Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager
        val clip = android.content.ClipData.newPlainText("Message", content)
        clipboard.setPrimaryClip(clip)
        Toast.makeText(requireContext(), "Copied to clipboard", Toast.LENGTH_SHORT).show()
    }
    
    private fun showEmptyState(show: Boolean) {
        if (show) {
            emptyStateText.visibility = View.VISIBLE
            recyclerView.visibility = View.GONE
        } else {
            emptyStateText.visibility = View.GONE
            recyclerView.visibility = View.VISIBLE
        }
    }
}




MessageAdapter.kt
package com.example.lilotest.ui.chat

import android.app.AlertDialog
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.ContextWrapper
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.GradientDrawable
import android.graphics.Typeface
import android.os.Handler
import android.os.Looper
import android.text.SpannableString
import android.text.Spanned
import android.text.style.BackgroundColorSpan
import android.text.style.ForegroundColorSpan
import android.text.style.RelativeSizeSpan
import android.text.style.StyleSpan
import android.text.style.TypefaceSpan
import android.util.Base64
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.Button
import android.widget.EditText
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.graphics.ColorUtils
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.example.lilotest.R
import com.example.lilotest.data.model.Message
import com.example.lilotest.data.model.MessageThread
import com.example.lilotest.data.model.MessageType
import com.example.lilotest.data.model.MessageChain
import com.example.lilotest.ui.theme.ThemeManager
import io.github.kbiakov.codeview.CodeView
import io.github.kbiakov.codeview.adapters.Options
import io.github.kbiakov.codeview.highlight.ColorTheme
import java.util.regex.Pattern

class MessageAdapter( 
    private val viewHolderFactory: MessageViewHolderFactory
) : ListAdapter<Message, MessageViewHolder>(MessageDiffCallback()) {

    @Deprecated("Use the constructor with a MessageViewHolderFactory parameter")
    constructor() : this(throw IllegalStateException("MessageAdapter requires a viewHolderFactory"))
    private var chatViewModel: ChatViewModel? = null
    private val TAG = "MessageAdapter"
    private val THEME_TAG = "ThemeDebug"
    private var themeManager: ThemeManager? = null

    private var versionNavigationListener: MessageVersionNavigationListener? = null

    fun setChatViewModel(viewModel: ChatViewModel) {
        this.chatViewModel = viewModel
    }

    fun setVersionNavigationListener(listener: MessageVersionNavigationListener) {
        this.versionNavigationListener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MessageViewHolder {

        // Initialize theme manager if not already done
        if (themeManager == null) {
            themeManager = ThemeManager(parent.context)
        }
        
        // Use the factory to create the ViewHolder
        return viewHolderFactory.create(parent, viewType)
    }

    interface MessageVersionNavigationListener {
        fun onPreviousVersion(threadId: String)
        fun onNextVersion(threadId: String)
        fun navigateToSpecificVersion(threadId: String, versionIndex: Int)
    }

    interface EditMessageListener {
        fun onMessageEdited(messageId: String, newContent: String)
    }

    private var editMessageListener: EditMessageListener? = null

    fun setEditMessageListener(listener: EditMessageListener) {
        this.editMessageListener = listener
    }

    /**
     * Helper function to determine if two messages share a common ancestor
     */
    private fun findCommonAncestor(message: Message, ancestorId: String, allChains: Collection<MessageChain>): Boolean {
        var currentMsg = message
        val visited = mutableSetOf<String>()
        
        while (currentMsg.originalMessageId != null && !visited.contains(currentMsg.id)) {
            visited.add(currentMsg.id)
            
            if (currentMsg.originalMessageId == ancestorId) {
                return true
            }
            
            // Find the message with this ID in any chain
            var found = false
            for (chain in allChains) {
                val ancestor = chain.messages.find { it.id == currentMsg.originalMessageId }
                if (ancestor != null) {
                    currentMsg = ancestor
                    found = true
                    break
                }
            }
            if (!found) break
        }
        
        return false
    }

    override fun onBindViewHolder(holder: MessageViewHolder, position: Int) {
        val message = getItem(position)

        try {
            // Initialize theme manager if not already done
            if (themeManager == null) {
                themeManager = ThemeManager(holder.itemView.context)
            }
            
            // Use the factory to update the ViewHolder styling
            val viewType = getItemViewType(position)
            viewHolderFactory.updateStyle(holder, viewType)

            // Get the message content safely
            val content = message.content ?: ""

            Log.d(TAG, "Processing message ID ${message.id}, content length: ${content.length}")

            // Check for code blocks or tables
            val hasSpecialBlocks = content.contains("```") || containsMarkdownTable(content)

            if (hasSpecialBlocks) {
                // Process content with special blocks
                processMessageWithSpecialBlocks(content, holder, message)
            } else {
                // Use text response for other parts
                val formattedText = formatTextWithoutCodeBlocks(content, holder.itemView.context)

                // Make sure regular text view has content
                holder.getContentTextView()?.apply {
                    visibility = View.VISIBLE
                    text = formattedText
                }

                // Set timestamp
                holder.setTimestamp(message.timestamp)
            }

            if (viewType == MessageViewHolderFactory.VIEW_TYPE_USER) {
                val threadId = message.threadId

                val editButton = holder.itemView.findViewById<ImageButton>(R.id.edit_message_button)
                val nextButton = holder.itemView.findViewById<ImageButton>(R.id.next_version_button)
                val prevButton = holder.itemView.findViewById<ImageButton>(R.id.prev_version_button)
                val versionCounterView = holder.itemView.findViewById<TextView>(R.id.version_counter)

                // Get the user message text color from ThemeManager
                val userMessageTextColor = themeManager?.getThemeColor(ThemeManager.ThemeColorType.USER_MESSAGE_TEXT) 
                    ?: ContextCompat.getColor(holder.itemView.context, R.color.light_user_msg_text)
                
                // Set the button colors to match the user message text color
                prevButton?.setColorFilter(userMessageTextColor)
                nextButton?.setColorFilter(userMessageTextColor)
                editButton?.setColorFilter(userMessageTextColor)
                versionCounterView?.setTextColor(userMessageTextColor)

                // Set click listener to show edit dialog
                editButton.setOnClickListener {
                    if (threadId != null) {
                        showEditMessageDialog(holder.itemView.context, message)
                    }
                }

                // Default state - hide navigation buttons
                prevButton?.visibility = View.GONE
                nextButton?.visibility = View.GONE
                versionCounterView?.visibility = View.GONE

                if (threadId != null) {
                    val thread = getMessageThreadInfo(threadId) ?: return
                    
                    // In onBindViewHolder, replace the version checking logic with this:

                    if (threadId != null && thread.versions.size > 1) {
                        // Get current version of the thread
                        val currentVersion = thread.currentVersionIndex
                            
                        // Get the lineage ID of this message
                        val messageLineageId = message.editLineageId ?: message.id
                            
                        Log.d(TAG, "Message at position $position: id=${message.id}, lineageId=$messageLineageId")
                            
                        // Find all versions that contain this message's lineage
                        val relatedVersions = mutableListOf<Int>()
                        val seenMessages = mutableSetOf<String>()
                            
                        // Check ALL versions and chains for related messages
                        for ((versionIndex, version) in thread.versions.withIndex()) {
                            // Check all chains that originate from this version
                            val chainsForVersion = thread.chains.values.filter { it.fromVersionIndex == versionIndex }
                                
                            for (chain in chainsForVersion) {
                                for (chainMsg in chain.messages) {
                                    if (chainMsg.type == message.type && 
                                        (chainMsg.editLineageId == messageLineageId || 
                                         chainMsg.id == messageLineageId ||
                                         chainMsg.originalMessageId == message.id ||
                                         message.originalMessageId == chainMsg.id)) {
                                            
                                        if (!seenMessages.contains(chainMsg.id)) {
                                            seenMessages.add(chainMsg.id)
                                            Log.d(TAG, "Found related message in version $versionIndex: id=${chainMsg.id}, content=${chainMsg.content?.take(20)}")
                                                
                                            if (!relatedVersions.contains(versionIndex)) {
                                                relatedVersions.add(versionIndex)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                            
                        Log.d(TAG, "Related version indices for message ${message.id}: $relatedVersions")
                            
                        // Only show version counter if this message has multiple versions
                        if (relatedVersions.size > 1) {
                            // Sort indices for consistent navigation
                            relatedVersions.sort()
                                
                            // Find which version we're currently viewing
                            val currentVersionPos = relatedVersions.indexOf(currentVersion)
                                
                            if (currentVersionPos >= 0) {
                                Log.d(TAG, "Setting counter to ${currentVersionPos + 1}/${relatedVersions.size}")
                                    
                                // Show navigation controls
                                prevButton?.visibility = View.VISIBLE
                                nextButton?.visibility = View.VISIBLE
                                versionCounterView?.visibility = View.VISIBLE
                                    
                                // Set version counter text
                                versionCounterView?.text = "${currentVersionPos + 1}/${relatedVersions.size}"
                                    
                                // Enable/disable navigation buttons
                                prevButton?.isEnabled = currentVersionPos > 0
                                prevButton?.alpha = if (currentVersionPos > 0) 1.0f else 0.5f
                                    
                                nextButton?.isEnabled = currentVersionPos < relatedVersions.size - 1
                                nextButton?.alpha = if (currentVersionPos < relatedVersions.size - 1) 1.0f else 0.5f
                                    
                                // Set click listeners
                                prevButton?.setOnClickListener {
                                    if (currentVersionPos > 0) {
                                        val prevVersionIdx = relatedVersions[currentVersionPos - 1]
                                        versionNavigationListener?.navigateToSpecificVersion(threadId, prevVersionIdx)
                                    }
                                }
                                    
                                nextButton?.setOnClickListener {
                                    if (currentVersionPos < relatedVersions.size - 1) {
                                        val nextVersionIdx = relatedVersions[currentVersionPos + 1]
                                        versionNavigationListener?.navigateToSpecificVersion(threadId, nextVersionIdx)
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                // Hide navigation buttons for non-user messages
                val prevButton = holder.itemView.findViewById<ImageButton>(R.id.prev_version_button)
                val nextButton = holder.itemView.findViewById<ImageButton>(R.id.next_version_button)
                val versionCounterView = holder.itemView.findViewById<TextView>(R.id.version_counter)                

                prevButton?.visibility = View.GONE
                nextButton?.visibility = View.GONE
                versionCounterView?.visibility = View.GONE
            }

            // Process images
            if (message.containsImage) {
                val imageView = holder.itemView.findViewById<ImageView>(R.id.message_image)
                val progressBar = holder.itemView.findViewById<ProgressBar>(R.id.image_loading_progress)

                if (imageView != null && progressBar != null) {
                    Log.d(TAG, "Loading image for message: ${message.id}")
                    progressBar.visibility = View.VISIBLE

                    if (!message.imageUrl.isNullOrEmpty()) {
                        Log.d(TAG, "Loading from URL: ${message.imageUrl}")
                        // Loading from URL
                        Glide.with(holder.itemView.context)
                            .load(message.imageUrl)
                            .apply(RequestOptions()
                                .diskCacheStrategy(DiskCacheStrategy.ALL)
                                .error(R.drawable.ic_error_placeholder))
                            .into(imageView)
                            .clearOnDetach()

                        progressBar.visibility = View.GONE

                    } else if (!message.imageData.isNullOrEmpty()) {
                        try {
                            Log.d(TAG, "Loading from base 64 data")
                            if (message.imageData.startsWith("data:image")) {
                                // Parse image data
                                val base64Data = message.imageData.substring(message.imageData.indexOf(",") + 1)
                                val imageBytes = Base64.decode(base64Data, Base64.DEFAULT)

                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            } else {
                                // Try decoding directly
                                val imageBytes = Base64.decode(message.imageData, Base64.DEFAULT)
                                Glide.with(holder.itemView.context)
                                    .load(imageBytes)
                                    .apply(RequestOptions()
                                        .diskCacheStrategy(DiskCacheStrategy.NONE)
                                        .error(R.drawable.ic_error_placeholder))
                                    .into(imageView)
                                    .clearOnDetach()
                            }
                            progressBar.visibility = View.GONE
                        } catch (e: Exception) {
                            Log.e(TAG, "Error loading base64 image: ${e.message}")
                            progressBar.visibility = View.GONE
                        }
                    } else {
                        progressBar.visibility = View.GONE
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error binding view holder: ${e.message}")
            e.printStackTrace()

            // Fallback to text binding
            holder.getContentTextView()?.apply {
                visibility = View.VISIBLE
                text = message.content ?: ""
            }
            holder.setTimestamp(message.timestamp)
        }
    }

    private fun navigateToSpecificVersion(threadId: String, versionIndex: Int) {
        chatViewModel?.navigateToSpecificVersion(threadId, versionIndex)
    }

    private fun getMessageThreadInfo(threadId: String): MessageThread? {
        return chatViewModel?.getMessageThread(threadId)
    }

    private fun showEditMessageDialog(context: Context, message: Message) {
        // Initialize theme manager if not already done
        if (themeManager == null) {
            themeManager = ThemeManager(context)
        }

        val modalBackground = themeManager?.getThemeColor(ThemeManager.ThemeColorType.MODAL_BACKGROUND) ?: Color.WHITE
        val textColor = themeManager?.getThemeColor(ThemeManager.ThemeColorType.TEXT) ?: Color.BLACK
        val modalBorder = themeManager?.getThemeColor(ThemeManager.ThemeColorType.MODAL_BORDER) ?: Color.GRAY
        val userMsgBg = themeManager?.getThemeColor(ThemeManager.ThemeColorType.USER_MESSAGE_BACKGROUND) ?: Color.BLUE
        val userMsgText = themeManager?.getThemeColor(ThemeManager.ThemeColorType.USER_MESSAGE_TEXT) ?: Color.WHITE
        
        //Create dialog view
        val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_edit_message, null)

        // Get views from dialog
        val titleTextView = dialogView.findViewById<TextView>(R.id.dialog_title)
        val editInput = dialogView.findViewById<EditText>(R.id.edit_message_input)
        val cancelButton = dialogView.findViewById<Button>(R.id.cancel_button)
        val sendButton = dialogView.findViewById<Button>(R.id.send_button)

        // Style the dialog based on theme
        dialogView.setBackgroundColor(modalBackground)
        titleTextView.setTextColor(textColor)
        
        // Create a darker background for the input field
        val editTextBackground = editInput.background as GradientDrawable
        editTextBackground.setColor(ColorUtils.setAlphaComponent(modalBorder, 50))
        editTextBackground.setStroke(1, modalBorder)
        
        // Set text color for input field
        editInput.setTextColor(textColor)
        editInput.setHintTextColor(ColorUtils.setAlphaComponent(textColor, 128))
        
        // Style buttons
        cancelButton.setTextColor(textColor)
        sendButton.setBackgroundColor(userMsgBg)
        sendButton.setTextColor(userMsgText)
        
        // Pre-fill with current message text
        editInput.setText(message.content)
        
        // Build the dialog
        val dialog = AlertDialog.Builder(context)
            .setView(dialogView)
            .setCancelable(true)
            .create()
        
        // Set window background to be semi-transparent
        dialog.window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
        
        // Setup button listeners
        cancelButton.setOnClickListener {
            dialog.dismiss()
        }
        
        sendButton.setOnClickListener {
            val editedText = editInput.text.toString().trim()
            if (editedText.isNotEmpty() && editedText != message.content) {
                // Call the callback to handle the edited message
                editMessageListener?.onMessageEdited(message.id, editedText)
            }
            dialog.dismiss()
        }
        
        // Show the dialog
        dialog.show()
    }

    // Also add this extension function to find the activity from context
    private fun Context.findActivity(): AppCompatActivity? {
        var context = this
        while (context is ContextWrapper) {
            if (context is AppCompatActivity) {
                return context
            }
            context = context.baseContext
        }
        return null
    }

ChatHistoryUtils.kt

package com.example.lilotest.data.local

import android.content.Context
import android.net.Uri
import android.util.Log
import com.google.gson.GsonBuilder
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.concurrent.Executors
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

/**
 * Utility class for exporting and importing chat history
 */
class ChatHistoryUtils(private val context: Context) {
    private val TAG = "ChatHistoryUtils"
    private val HISTORY_FILENAME = "chat_history.json"
    private val executorService = Executors.newSingleThreadExecutor()
    
    /**
     * Export chat history to external storage in a zip file
     * Returns the file Uri if successful, null otherwise
     */
    fun exportChatHistory(listener: (Uri?) -> Unit) {
        executorService.execute {
            try {
                // Create a timestamped filename for the export
                val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
                val exportFilename = "lilotest_chat_history_$timestamp.zip"
                
                // Create a file in the app's cache directory
                val exportFile = File(context.cacheDir, exportFilename)
                if (exportFile.exists()) {
                    exportFile.delete()
                }
                
                // Get the source history file
                val historyFile = File(context.filesDir, HISTORY_FILENAME)
                if (!historyFile.exists()) {
                    Log.d(TAG, "No chat history file found to export")
                    listener(null)
                    return@execute
                }
                
                // Create a zip file containing the chat history
                ZipOutputStream(FileOutputStream(exportFile)).use { zipOut ->
                    FileInputStream(historyFile).use { fileIn ->
                        // Add the history file to the zip
                        val zipEntry = ZipEntry(HISTORY_FILENAME)
                        zipOut.putNextEntry(zipEntry)
                        
                        val buffer = ByteArray(1024)
                        var len: Int
                        while (fileIn.read(buffer).also { len = it } > 0) {
                            zipOut.write(buffer, 0, len)
                        }
                        
                        zipOut.closeEntry()
                    }
                }
                
                // Create a content URI for the file using FileProvider
                val uri = androidx.core.content.FileProvider.getUriForFile(
                    context,
                    "${context.packageName}.fileprovider",
                    exportFile
                )
                
                Log.d(TAG, "Chat history exported successfully to $uri")
                listener(uri)
                
            } catch (e: Exception) {
                Log.e(TAG, "Error exporting chat history", e)
                listener(null)
            }
        }
    }
    
    /**
     * Import chat history from a zip file
     * Returns true if successful, false otherwise
     */
    fun importChatHistory(uri: Uri, listener: (Boolean) -> Unit) {
        executorService.execute {
            try {
                context.contentResolver.openInputStream(uri)?.use { inputStream ->
                    ZipInputStream(inputStream).use { zipIn ->
                        var zipEntry = zipIn.nextEntry
                        
                        while (zipEntry != null) {
                            if (zipEntry.name == HISTORY_FILENAME) {
                                // Create a temporary file to store the extracted JSON
                                val tempFile = File(context.cacheDir, "temp_$HISTORY_FILENAME")
                                if (tempFile.exists()) {
                                    tempFile.delete()
                                }
                                
                                // Extract the JSON file
                                FileOutputStream(tempFile).use { fileOut ->
                                    val buffer = ByteArray(1024)
                                    var len: Int
                                    while (zipIn.read(buffer).also { len = it } > 0) {
                                        fileOut.write(buffer, 0, len)
                                    }
                                }
                                
                                // Validate the JSON
                                val isValid = validateJsonFormat(tempFile)
                                if (!isValid) {
                                    Log.e(TAG, "Invalid chat history JSON format")
                                    listener(false)
                                    return@execute
                                }
                                
                                // Replace the existing history file
                                val historyFile = File(context.filesDir, HISTORY_FILENAME)
                                tempFile.copyTo(historyFile, true)
                                
                                Log.d(TAG, "Chat history imported successfully")
                                listener(true)
                                return@execute
                            }
                            
                            zipIn.closeEntry()
                            zipEntry = zipIn.nextEntry
                        }
                        
                        Log.e(TAG, "Chat history file not found in zip")
                        listener(false)
                    }
                } ?: run {
                    Log.e(TAG, "Could not open input stream for URI")
                    listener(false)
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Error importing chat history", e)
                listener(false)
            }
        }
    }
    
    /**
     * Check if the imported JSON is valid
     */
    private fun validateJsonFormat(jsonFile: File): Boolean {
        try {
            val gson = GsonBuilder().create()
            InputStreamReader(FileInputStream(jsonFile)).use { reader ->
                // Try to parse as a list of StoredThread objects
                gson.fromJson(reader, Array<StoredThread>::class.java)
                return true
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error validating JSON format", e)
            return false
        }
    }
    
    /**
     * Create a backup of the current chat history
     */
    fun createBackup() {
        executorService.execute {
            try {
                val historyFile = File(context.filesDir, HISTORY_FILENAME)
                if (!historyFile.exists()) {
                    return@execute
                }
                
                val backupDir = File(context.filesDir, "backups")
                if (!backupDir.exists()) {
                    backupDir.mkdir()
                }
                
                // Create a timestamped backup file
                val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
                val backupFile = File(backupDir, "${HISTORY_FILENAME}.backup.$timestamp")
                
                // Copy the current history file to the backup
                historyFile.copyTo(backupFile)
                
                // Keep only the 5 most recent backups
                val backups = backupDir.listFiles()?.filter {
                    it.name.startsWith("${HISTORY_FILENAME}.backup")
                }?.sortedByDescending { it.lastModified() }
                
                backups?.drop(5)?.forEach { it.delete() }
                
                Log.d(TAG, "Chat history backup created: ${backupFile.name}")
                
            } catch (e: IOException) {
                Log.e(TAG, "Error creating chat history backup", e)
            }
        }
    }
}


MessageRepository.kt

package com.example.lilotest.data.remote


import android.util.Log
import com.example.lilotest.data.model.Message
import okhttp3.OkHttpClient
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.concurrent.TimeUnit

class MessageRepository {
    private val TAG = "MessageRepository"
    private val apiService: ChatApiService

    init {
        val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()

        val retrofit = Retrofit.Builder()
            .baseUrl("https://lilotest.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        apiService = retrofit.create(ChatApiService::class.java)
    }

    /**
     * Sends a user message to the Gemini API with conversation history context
     *
     * @param message The user's current message
     * @param conversationHistory List of previous messages in the conversation
     * @param activeChainId ID of the active message chain
     * @return The model's response as a string
     */
    suspend fun sendMessage(
        message: String,
        conversationHistory: List<Message> = emptyList(),
        activeChainId: String? = null
    ): String {
        // Get only messages relevant to the current chain
        val relevantMessages = if (activeChainId != null) {
            PromptBuilder.getRelevantMessagesForPrompt(conversationHistory, activeChainId)
        } else {
            emptyList()
        }

        // Build a prompt that includes conversation history
        val promptWithHistory = PromptBuilder.buildPromptWithHistory(message, relevantMessages)

        // Log the prepared prompt for debugging
        Log.d(TAG, "Sending message with history context, total messages: ${relevantMessages.size}")

        // Send the enriched prompt to the API
        val response = apiService.sendMessage(MessageRequest(promptWithHistory))

        if (response.isSuccessful) {
            val messageResponse = response.body()
            return messageResponse?.response?.text ?: "Empty response"
        } else {
            throw Exception("Failed to send message: ${response.code()} - ${response.message()}")
        }
    }
}